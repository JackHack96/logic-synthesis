<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>User's Manual</TITLE>
<META NAME="description" CONTENT="User's Manual">
<META NAME="keywords" CONTENT="cuddIntro">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="cuddIntro.css">
<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="cuddIntro.html">
<LINK REL="next" HREF="node4.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html268"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="icons/next_motif.gif"></A> 
<A NAME="tex2html265"
 HREF="cuddIntro.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="icons/up_motif.gif"></A> 
<A NAME="tex2html259"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="icons/previous_motif.gif"></A>  
<A NAME="tex2html267"
 HREF="node8.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="icons/index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html269"
 HREF="node4.html">Programmer's Manual</A>
<B> Up:</B> <A NAME="tex2html266"
 HREF="cuddIntro.html">CUDD: CU Decision Diagram</A>
<B> Previous:</B> <A NAME="tex2html260"
 HREF="node2.html">How to Get CUDD</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><strong>Subsections</strong></A>
<UL>
<LI><A NAME="tex2html270"
 HREF="node3.html#SECTION00031000000000000000">Compiling and Linking</A>
<LI><A NAME="tex2html271"
 HREF="node3.html#SECTION00032000000000000000">Basic Data Structures</A>
<UL>
<LI><A NAME="tex2html272"
 HREF="node3.html#SECTION00032100000000000000">Nodes</A>
<LI><A NAME="tex2html273"
 HREF="node3.html#SECTION00032200000000000000">The Manager</A>
<LI><A NAME="tex2html274"
 HREF="node3.html#SECTION00032300000000000000">Cache</A>
</UL>
<LI><A NAME="tex2html275"
 HREF="node3.html#SECTION00033000000000000000">Initializing and Shutting Down a DdManager</A>
<LI><A NAME="tex2html276"
 HREF="node3.html#SECTION00034000000000000000">Setting Parameters</A>
<LI><A NAME="tex2html277"
 HREF="node3.html#SECTION00035000000000000000">Constant Functions</A>
<UL>
<LI><A NAME="tex2html278"
 HREF="node3.html#SECTION00035100000000000000">One, Logic Zero, and Arithmetic Zero</A>
<LI><A NAME="tex2html279"
 HREF="node3.html#SECTION00035200000000000000">Predefined Constants</A>
<LI><A NAME="tex2html280"
 HREF="node3.html#SECTION00035300000000000000">Background</A>
<LI><A NAME="tex2html281"
 HREF="node3.html#SECTION00035400000000000000">New Constants</A>
</UL>
<LI><A NAME="tex2html282"
 HREF="node3.html#SECTION00036000000000000000">Creating Variables</A>
<UL>
<LI><A NAME="tex2html283"
 HREF="node3.html#SECTION00036100000000000000">New BDD and ADD Variables</A>
<LI><A NAME="tex2html284"
 HREF="node3.html#SECTION00036200000000000000">New ZDD Variables</A>
</UL>
<LI><A NAME="tex2html285"
 HREF="node3.html#SECTION00037000000000000000">Basic BDD Manipulation</A>
<LI><A NAME="tex2html286"
 HREF="node3.html#SECTION00038000000000000000">Basic ADD Manipulation</A>
<LI><A NAME="tex2html287"
 HREF="node3.html#SECTION00039000000000000000">Basic ZDD Manipulation</A>
<LI><A NAME="tex2html288"
 HREF="node3.html#SECTION000310000000000000000">Converting ADDs to BDDs and Vice Versa</A>
<LI><A NAME="tex2html289"
 HREF="node3.html#SECTION000311000000000000000">Converting BDDs to ZDDs and Vice Versa</A>
<LI><A NAME="tex2html290"
 HREF="node3.html#SECTION000312000000000000000">Variable Reordering for BDDs and ADDs</A>
<LI><A NAME="tex2html291"
 HREF="node3.html#SECTION000313000000000000000">Grouping Variables</A>
<LI><A NAME="tex2html292"
 HREF="node3.html#SECTION000314000000000000000">Variable Reordering for ZDDs</A>
<LI><A NAME="tex2html293"
 HREF="node3.html#SECTION000315000000000000000">Keeping Consistent Variable Orders for BDDs and ZDDs</A>
<LI><A NAME="tex2html294"
 HREF="node3.html#SECTION000316000000000000000">Hooks</A>
<LI><A NAME="tex2html295"
 HREF="node3.html#SECTION000317000000000000000">The SIS/VIS Interface</A>
<UL>
<LI><A NAME="tex2html296"
 HREF="node3.html#SECTION000317100000000000000">Using the CUDD Package in SIS</A>
</UL>
<LI><A NAME="tex2html297"
 HREF="node3.html#SECTION000318000000000000000">Writing Decision Diagrams to a File</A>
<LI><A NAME="tex2html298"
 HREF="node3.html#SECTION000319000000000000000">Saving and Restoring BDDs</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00030000000000000000">&#160;</A>
<A NAME="sec:user">&#160;</A>
<BR>
User's Manual
</H1>

<P>
This section describes the use of the CUDD package as a black box.

<P>

<H2><A NAME="SECTION00031000000000000000">&#160;</A>
<A NAME="sec:compileExt">&#160;</A><A NAME="78">&#160;</A>
<BR>
Compiling and Linking
</H2>

<P>
To build an application that uses the CUDD package, you should add
<PRE>
#include "util.h"
#include "cudd.h"
</PRE><A NAME="81">&#160;</A>
to your source files, and should link
<code>libcudd.a</code><A NAME="82">&#160;</A>,
<code>libmtr.a</code><A NAME="83">&#160;</A>,
<code>libst.a</code><A NAME="84">&#160;</A>, and
<code>libutil.a</code><A NAME="85">&#160;</A> to your executable. (All these
libraries are part of the distribution.) Some
platforms require specific compiler and linker flags.  Refer to the
<TT>Makefile<A NAME="86">&#160;</A></TT> in the top level directory of the
distribution.

<P>

<H2><A NAME="SECTION00032000000000000000">&#160;</A>
<A NAME="sec:struct">&#160;</A>
<BR>
Basic Data Structures
</H2>

<P>

<H3><A NAME="SECTION00032100000000000000">&#160;</A>
<A NAME="sec:nodes">&#160;</A>
<BR>
Nodes
</H3>

<P>
BDDs, ADDs, and ZDDs are made of DdNode's. A DdNode<A NAME="91">&#160;</A>
(node<A NAME="92">&#160;</A> for short) is a structure with several fields. Those
that are of interest to the application that uses the CUDD package as
a black box are the variable index<A NAME="93">&#160;</A>, the
reference<A NAME="94">&#160;</A> count, and the value. The
remaining fields are pointers that connect nodes among themselves and
that are used to implement the unique<A NAME="95">&#160;</A> table. (See
Section&nbsp;<A HREF="node3.html#sec:manager">3.2.2</A>.)

<P>
The <EM>index</EM> field holds the name of the variable that labels the
node. The index of a variable is a permanent attribute that reflects
the order<A NAME="98">&#160;</A> of creation.  Index 0 corresponds to
the variable created first. On a machine with 32-bit pointers, the
maximum number of variables is the largest value that can be stored in
an unsigned short integer minus 1. The largest index is reserved for
the constant<A NAME="99">&#160;</A> nodes. When 64-bit pointers are
used, the maximum number of variables is the largest value that can be
stored in an unsigned integer minus 1.

<P>
When variables are reordered to reduce the size of the decision
diagrams, the variables may shift in the order, but they retain their
indices. The package keeps track of the variable
permutation<A NAME="100">&#160;</A> (and its inverse). The
application is not affected by variable reordering<A NAME="101">&#160;</A>,
except in the following cases.
<UL>
<LI>If the application uses
  generators<A NAME="103">&#160;</A> (<A NAME="tex2html3"
 HREF="cuddExtDet.html#Cudd_ForeachCube"><EM>Cudd_ForeachCube</EM></A>
<A NAME="1419">&#160;</A> and <A NAME="tex2html4"
 HREF="cuddExtDet.html#Cudd_ForeachNode"><EM>Cudd_ForeachNode</EM></A>
<A NAME="1421">&#160;</A>) and reordering is enabled, then it
  must take care not to call any operation that may create new nodes
  (and hence possibly trigger reordering). This is because the cubes
  (i.e., paths) and nodes of a diagram change as a result of reordering.
<LI>If the application uses <A NAME="tex2html5"
 HREF="cuddExtDet.html#Cudd_bddConstrain"><EM>    Cudd_bddConstrain</EM></A><A NAME="1423">&#160;</A> and reordering

takes place, then the property of <A NAME="tex2html6"
 HREF="cuddExtDet.html#Cudd_bddConstrain"><EM>Cudd_bddConstrain</EM></A>
of being an
  image restrictor is lost.
</UL>
<P>
The CUDD package relies on garbage<A NAME="116">&#160;</A>
collection to reclaim the memory used by diagrams that are no longer
in use. The scheme employed for garbage collection is based on keeping
a reference<A NAME="117">&#160;</A> count for each node.  The
references that are counted are both the internal references
(references from other nodes) and external references (typically
references from the calling environment).  When an application creates
a new BDD<A NAME="118">&#160;</A>, ADD<A NAME="119">&#160;</A>, or ZDD<A NAME="120">&#160;</A>,
it must increase its reference count explicitly, through
a call to <A NAME="tex2html7"
 HREF="cuddExtDet.html#Cudd_Ref"><EM>Cudd_Ref</EM></A><A NAME="1425">&#160;</A>.  Similarly, when a
diagram is no longer needed, the application must call <A NAME="tex2html8"
 HREF="cuddExtDet.html#Cudd_RecursiveDeref"><EM>  Cudd_RecursiveDeref</EM></A><A NAME="1427">&#160;</A> (for BDDs
and ADDs) or <A NAME="tex2html9"
 HREF="cuddExtDet.html#Cudd_RecursiveDerefZdd"><EM>  Cudd_RecursiveDerefZdd</EM></A><A NAME="1429">&#160;</A>
(for ZDDs) to ``recycle<A NAME="130">&#160;</A>" the nodes of the
diagram.

<P>
Terminal<A NAME="131">&#160;</A> nodes carry a value. This is especially
important for ADDs.  By default, the value is a double
<A NAME="132">&#160;</A>.
To change to something different (e.g., an integer), the
package must be modified and recompiled.  Support for this process is
currently very rudimentary.

<P>

<H3><A NAME="SECTION00032200000000000000">&#160;</A>
<A NAME="134">&#160;</A><A NAME="sec:manager">&#160;</A>
<BR>
The Manager
</H3>

<P>
All nodes used in BDDs, ADDs, and ZDDs are kept in special
hash<A NAME="136">&#160;</A> tables called the <EM>  unique<A NAME="137">&#160;</A> tables</EM>. Specifically, BDDs and ADDs
share the same unique table, whereas ZDDs have their own table.  As
the name implies, the main purpose of the unique table is to guarantee
that each node is unique; that is, there is no other node labeled by
the same variable and with the same children. This uniqueness property
makes decision diagrams canonical<A NAME="138">&#160;</A>. The
unique<A NAME="139">&#160;</A> tables and some auxiliary data structures
make up the DdManager<A NAME="140">&#160;</A> (manager<A NAME="141">&#160;</A> for
short).  Though the application that uses only the exported functions
needs not be concerned with most details of the manager, it has to
deal with the manager in the following sense. The application must
initialize the manager by calling an appropriate function. (See
Section&nbsp;<A HREF="node3.html#sec:init">3.3</A>.) Subsequently, it must pass a pointer to the
manager to all the functions that operate on decision diagrams.

<P>
With the exception of a few statistical counters<A NAME="143">&#160;</A>, there are no global<A NAME="144">&#160;</A> variables in
the CUDD package. Therefore, it is quite possible to have multiple
managers simultaneously active in the same application.<A NAME="tex2html10"
 HREF="footnode.html#foot145"><SUP>1</SUP></A> It is the pointers to
the managers that tell the functions on what data they should operate.

<P>

<H3><A NAME="SECTION00032300000000000000">&#160;</A>
<A NAME="147">&#160;</A><A NAME="sec:memoize">&#160;</A>
<BR>
Cache
</H3>

<P>
Efficient recursive manipulation of decision diagrams requires the use
of a table to store computed results. This table<A NAME="149">&#160;</A>
is called here the <EM>cache<A NAME="150">&#160;</A></EM> because it is
effectively handled like a cache of variable but limited capacity. The
CUDD package starts by default with a small cache, and increases its
size until either no further benefit is achieved, or a limit size is
reached. The user can influence this policy by choosing initial and
limit values for the cache size.

<P>
Too small a cache will cause frequent overwriting of useful results.
Too large a cache will cause overhead, because the whole cache is
scanned every time garbage<A NAME="151">&#160;</A> collection takes
place. The optimal parameters depend on the specific application. The
default parameters work reasonably well for a large spectrum of
applications.

<P>
The cache<A NAME="152">&#160;</A> of the CUDD package is used by most recursive
functions of the package, and can be used by user-supplied functions
as well. (See Section&nbsp;<A HREF="node4.html#sec:cache">4.4</A>.)

<P>

<H2><A NAME="SECTION00033000000000000000">&#160;</A>
<A NAME="155">&#160;</A><A NAME="sec:init">&#160;</A>
<BR>
Initializing and Shutting Down a DdManager
</H2>

<P>
To use the functions in the CUDD package, one has first to initialize
the package itself by calling <A NAME="tex2html11"
 HREF="cuddExtDet.html#Cudd_Init"><EM>  Cudd_Init</EM></A><A NAME="1431">&#160;</A>.  This function takes four
parameters:
<UL>
<LI>numVars<A NAME="161">&#160;</A>: It is the initial number of variables

for BDDs and ADDs. If the total number of variables needed by the
  application is known, then it is slightly more efficient to create a
  manager with that number of variables. If the number is unknown, it
  can be set to 0, or to any other lower bound on the number of
  variables.  Requesting more variables than are actually needed is
  not incorrect, but is not efficient.
<LI>numVarsZ<A NAME="162">&#160;</A>: It is the initial number of variables
  for ZDDs. See Sections&nbsp;<A HREF="node3.html#sec:basicZDD">3.9</A> and&nbsp;<A HREF="node3.html#sec:convertZ">3.11</A> for
  a discussion of the value of this argument.
<LI>numSlots<A NAME="165">&#160;</A>: Determines the initial size of each
  subtable<A NAME="166">&#160;</A> of the unique<A NAME="167">&#160;</A> table.
  There is a subtable for each variable. The size of each subtable is
  dynamically adjusted to reflect the number of nodes.  It is normally
  O.K. to use the default value for this parameter, which is
  CUDD_UNIQUE_SLOTS<A NAME="168">&#160;</A>.
<LI>cacheSize<A NAME="169">&#160;</A>: It is the initial size (number of
  entries) of the cache<A NAME="170">&#160;</A>. Its default value is
  CUDD_CACHE_SLOTS<A NAME="171">&#160;</A>.
<LI>maxMemory<A NAME="172">&#160;</A>: It is the target value for the
  maximum memory occupation (in bytes). The package uses this value to
  decide two parameters.
  <UL>
<LI>the maximum size to which the cache will grow, regardless of
    the hit rate or the size of the unique<A NAME="174">&#160;</A> table.
<LI>the maximum size to which growth of the unique table will be
    preferred to garbage collection.
  </UL>  If maxMemory is set to 0, CUDD tries to guess a good value based on
  the available memory.
</UL>A typical call to <A NAME="tex2html12"
 HREF="cuddExtDet.html#Cudd_Init"><EM>Cudd_Init</EM></A><A NAME="1433">&#160;</A> may look
like this:
<PRE>
  manager = Cudd_Init(0,0,CUDD_UNIQUE_SLOTS,CUDD_CACHE_SLOTS,0);
</PRE>To reclaim all the memory associated with a manager, an application
must call <A NAME="tex2html13"
 HREF="cuddExtDet.html#Cudd_Quit"><EM>Cudd_Quit</EM></A><A NAME="1435">&#160;</A>. This is normally
done before exiting.

<P>

<H2><A NAME="SECTION00034000000000000000">&#160;</A>
<A NAME="sec:params">&#160;</A>
<BR>
Setting Parameters
</H2>

<P>
The package provides several functions to set the parameters that
control various functions. For instance, the package has an automatic
way of determining whether a larger unique<A NAME="187">&#160;</A> table
would make the application run faster. In that case, the package
enters a ``fast growth<A NAME="188">&#160;</A>" mode in which resizing of
the unique subtables is favored over garbage<A NAME="189">&#160;</A>
collection. When the unique table reaches a given size, however, the
package returns to the normal ``slow growth" mode, even though the
conditions that caused the transition to fast growth still prevail.
The limit size for fast growth<A NAME="190">&#160;</A> can be read by <A NAME="tex2html14"
 HREF="cuddExtDet.html#Cudd_ReadLooseUpTo"><EM>  Cudd_ReadLooseUpTo</EM></A><A NAME="1437">&#160;</A> and changed
by <A NAME="tex2html15"
 HREF="cuddExtDet.html#Cudd_SetLooseUpTo"><EM>Cudd_SetLooseUpTo</EM></A><A NAME="1439">&#160;</A>.  Similar
pairs of functions exist for several other parameters. See also
Section&nbsp;<A HREF="node4.html#sec:stats">4.8</A>.

<P>

<H2><A NAME="SECTION00035000000000000000">&#160;</A>
<A NAME="199">&#160;</A><A NAME="sec:const">&#160;</A>
<BR>
Constant Functions
</H2>

<P>
The CUDD Package defines several constant functions. These functions
are created when the manager<A NAME="201">&#160;</A> is initialized, and are accessible
through the manager itself.

<P>

<H3><A NAME="SECTION00035100000000000000">&#160;</A>
<A NAME="203">&#160;</A><A NAME="204">&#160;</A><A NAME="sec:zero">&#160;</A>
<BR>
One, Logic Zero, and Arithmetic Zero
</H3>

<P>
The constant<A NAME="206">&#160;</A> 1 (returned by <A NAME="tex2html16"
 HREF="cuddExtDet.html#Cudd_ReadOne"><EM>  Cudd_ReadOne</EM></A><A NAME="1441">&#160;</A>) is common to BDDs,
ADDs, and ZDDs.  However, its meaning is different for ADDs and BDDs,
on the one hand, and ZDDs, on the other hand. The diagram consisting
of the constant 1 node only represents the constant 1 function for
ADDs and BDDs. For ZDDs, its meaning depends on the number of
variables: It is the conjunction of the complements of all variables.
Conversely, the representation of the constant 1 function depends on
the number of variables. The constant 1 function of <I>n</I> variables is
returned by <A NAME="tex2html17"
 HREF="cuddExtDet.html#Cudd_ReadZddOne"><EM>Cudd_ReadZddOne</EM></A><A NAME="1443">&#160;</A>.

<P>
The constant 0 is common to ADDs and ZDDs, but not to BDDs.  The
BDD<A NAME="213">&#160;</A> logic 0 is <B>not</B> associated
with the constant 0 function: It is obtained by complementation (<A NAME="tex2html18"
 HREF="cuddExtDet.html#Cudd_Not"><EM>  Cudd_Not</EM></A><A NAME="1445">&#160;</A>) of the constant 1. (It is also
returned by <A NAME="tex2html19"
 HREF="cuddExtDet.html#Cudd_ReadLogicZero"><EM>  Cudd_ReadLogicZero</EM></A><A NAME="1447">&#160;</A>.)  All
other constants are specific to ADDs.

<P>

<H3><A NAME="SECTION00035200000000000000">&#160;</A>
<A NAME="sec:predef-const">&#160;</A>
<BR>
Predefined Constants
</H3>

<P>
Besides 0 (returned by <A NAME="tex2html20"
 HREF="cuddExtDet.html#Cudd_ReadZero"><EM>Cudd_ReadZero</EM></A><A NAME="1449">&#160;</A>)
and 1, the following constant<A NAME="226">&#160;</A> functions are
created at initialization time.
<DL COMPACT>
<DT>1.
<DD>PlusInfinity<A NAME="228">&#160;</A> and
MinusInfinity<A NAME="229">&#160;</A>: On computers implementing the

IEEE<A NAME="230">&#160;</A> standard 754 for
  floating-point<A NAME="231">&#160;</A> arithmetic, these two constants
  are set to the signed infinities<A NAME="232">&#160;</A>. On the DEC
  Alphas<A NAME="233">&#160;</A>, the option <code>-ieee_with_no_inexact</code> or
  <code>-ieee_with_inexact</code> must be passed to the DEC compiler to get
  support of the IEEE standard. (The compiler still produces a
  warning, but it can be ignored.) Compiling<A NAME="234">&#160;</A> with
  those options may cause substantial performance degradation on the
  Evolution IV CPUs. (Especially if the application does use the
  infinities.)  The problem is reportedly solved in the Evolution V
  CPUs.  If <TT>gcc<A NAME="235">&#160;</A></TT> is used to compile CUDD on the
  Alphas, the symbol <TT>HAVE_IEEE_754<A NAME="236">&#160;</A></TT> must
  be undefined. (See the Makefile<A NAME="237">&#160;</A> for the details.)
  The values of these constants are returned by <A NAME="tex2html21"
 HREF="cuddExtDet.html#Cudd_ReadPlusInfinity"><EM>    Cudd_ReadPlusInfinity</EM></A><A NAME="1451">&#160;</A> and <A NAME="tex2html22"
 HREF="cuddExtDet.html#Cudd_ReadMinusInfinity"><EM>    Cudd_ReadMinusInfinity</EM></A><A NAME="1453">&#160;</A>.
<DT>2.
<DD>Epsilon<A NAME="244">&#160;</A>: This constant, initially set to

10<SUP>-12</SUP>, is used in comparing floating point values for equality.
  Its value is returned by <A NAME="tex2html23"
 HREF="cuddExtDet.html#Cudd_ReadEpsilon"><EM>    Cudd_ReadEpsilon</EM></A><A NAME="1455">&#160;</A>, and it can be

modified by calling <A NAME="tex2html24"
 HREF="cuddExtDet.html#Cudd_SetEpsilon"><EM>    Cudd_SetEpsilon</EM></A><A NAME="1457">&#160;</A>. Unlike the other

constants, it does not correspond to a node.
</DL>
<P>

<H3><A NAME="SECTION00035300000000000000">&#160;</A>
<A NAME="254">&#160;</A><A NAME="sec:background">&#160;</A>
<BR>
Background
</H3>

<P>
The background value is a constant<A NAME="256">&#160;</A> typically used
to represent non-existing arcs in graphs. Consider a shortest path
problem. Two nodes that are not connected by an arc can be regarded as
being joined by an arc<A NAME="257">&#160;</A> of infinite length. In
shortest path problems, it is therefore convenient to set the
background value to PlusInfinity<A NAME="258">&#160;</A>. In network flow
problems, on the other hand, two nodes not connected by an arc can be
regarded as joined by an arc<A NAME="259">&#160;</A> of 0 capacity.
For these problems, therefore, it is more convenient to set the
background value to 0.  In general, when representing
sparse<A NAME="260">&#160;</A> matrices, the background value is the value that
is assumed implicitly.

<P>
At initialization, the background value is set to 0. It can be read
with <A NAME="tex2html25"
 HREF="cuddExtDet.html#Cudd_ReadBackground"><EM>Cudd_ReadBackground</EM></A><A NAME="1459">&#160;</A>,
and modified with <A NAME="tex2html26"
 HREF="cuddExtDet.html#Cudd_SetBackground"><EM>Cudd_SetBackground</EM></A>.  The background value
affects procedures that read sparse matrices/graphs (<A NAME="tex2html27"
 HREF="cuddExtDet.html#Cudd_addRead"><EM>  Cudd_addRead</EM></A><A NAME="1461">&#160;</A> and <A NAME="tex2html28"
 HREF="cuddExtDet.html#Cudd_addHarwell"><EM>  Cudd_addHarwell</EM></A><A NAME="1463">&#160;</A>), procedures that
print out sum-of-product<A NAME="272">&#160;</A> expressions
for ADDs (<A NAME="tex2html29"
 HREF="cuddExtDet.html#Cudd_PrintMinterm"><EM>  Cudd_PrintMinterm</EM></A><A NAME="1465">&#160;</A>), generators
of cubes (<A NAME="tex2html30"
 HREF="cuddExtDet.html#Cudd_ForeachCube"><EM>Cudd_ForeachCube</EM></A><A NAME="1467">&#160;</A>),
and procedures that count minterms<A NAME="279">&#160;</A> (<A NAME="tex2html31"
 HREF="cuddExtDet.html#Cudd_CountMinterm"><EM>  Cudd_CountMinterm</EM></A><A NAME="1469">&#160;</A>).

<P>

<H3><A NAME="SECTION00035400000000000000">&#160;</A>
<A NAME="sec:newconst">&#160;</A>
<BR>
New Constants
</H3>

<P>
New constant<A NAME="285">&#160;</A> can be created by calling <A NAME="tex2html32"
 HREF="cuddExtDet.html#Cudd_addConst"><EM>  Cudd_addConst</EM></A><A NAME="1471">&#160;</A>. This function will
retrieve the ADD<A NAME="289">&#160;</A> for the desired
constant, if it already exist, or it will create a new one. Obviously,
new constants should only be used when manipulating ADDs.

<P>

<H2><A NAME="SECTION00036000000000000000">&#160;</A>
<A NAME="sec:newvar">&#160;</A>
<BR>
Creating Variables
</H2>

<P>
Decision diagrams are typically created by combining simpler decision
diagrams. The simplest decision diagrams, of course, cannot be created
in that way.  Constant functions have been discussed in
Section&nbsp;<A HREF="node3.html#sec:const">3.5</A>. In this section we discuss the simple
variable functions, also known as <EM>  projection<A NAME="293">&#160;</A> functions</EM>.

<P>

<H3><A NAME="SECTION00036100000000000000">&#160;</A>
<A NAME="sec:BDDADDvar">&#160;</A>
<BR>
New BDD and ADD Variables
</H3>

<P>
The projection<A NAME="296">&#160;</A> functions are distinct for
BDDs and ADDs. A projection function for BDDs consists of an internal
node with both outgoing arcs pointing to the constant 1. The <EM>  else</EM> arc<A NAME="298">&#160;</A> is complemented.

<P>
An ADD projection function, on the other hand, has the <EM>else</EM>
pointer directed to the arithmetic<A NAME="300">&#160;</A> zero
function. One should never mix the two types of variables. BDD
variables should be used when manipulating BDDs, and ADD variables
should be used when manipulating ADDs.  Three functions are provided
to create BDD variables:
<UL>
<LI><A NAME="tex2html33"
 HREF="cuddExtDet.html#Cudd_bddIthVar"><EM>Cudd_bddIthVar</EM></A><A NAME="1473">&#160;</A>: Returns

the projection<A NAME="305">&#160;</A> function with index <I>i</I>.
  If the function does not exist, it is created.
<LI><A NAME="tex2html34"
 HREF="cuddExtDet.html#Cudd_bddNewVar"><EM>Cudd_bddNewVar</EM></A><A NAME="1475">&#160;</A>: Returns a

new projection<A NAME="309">&#160;</A> function, whose index is
  the largest index in use at the time of the call, plus 1.
<LI><A NAME="tex2html35"
 HREF="cuddExtDet.html#Cudd_bddNewVarAtLevel"><EM>    Cudd_bddNewVarAtLevel</EM></A><A NAME="1477">&#160;</A>:

Similar to <A NAME="tex2html36"
 HREF="cuddExtDet.html#Cudd_bddNewVar"><EM>Cudd_bddNewVar</EM></A><A NAME="1479">&#160;</A>.  In

addition it allows to specify the position in the variable
  order<A NAME="316">&#160;</A> at which the new variable should be
  inserted. By contrast, <A NAME="tex2html37"
 HREF="cuddExtDet.html#Cudd_bddNewVar"><EM>    Cudd_bddNewVar</EM></A><A NAME="1481">&#160;</A> adds the new

variable at the end of the order.
</UL>The analogous functions for ADDs are <A NAME="tex2html38"
 HREF="cuddExtDet.html#Cudd_addIthVar"><EM>  Cudd_addIthVar</EM></A><A NAME="1483">&#160;</A>, <A NAME="tex2html39"
 HREF="cuddExtDet.html#Cudd_addNewVar"><EM>  Cudd_addNewVar</EM></A><A NAME="1485">&#160;</A>, and <A NAME="tex2html40"
 HREF="cuddExtDet.html#Cudd_addNewVarAtLevel"><EM>  Cudd_addNewVarAtLevel</EM></A><A NAME="1487">&#160;</A>.

<P>

<H3><A NAME="SECTION00036200000000000000">&#160;</A>
<A NAME="331">&#160;</A><A NAME="sec:ZDDvars">&#160;</A>
<BR>
New ZDD Variables
</H3>

<P>
Unlike the projection functions of BDDs and ADDs, the
projection<A NAME="333">&#160;</A> functions of ZDDs have diagrams
with <I>n</I>+1 nodes, where <I>n</I> is the number of variables. Therefore the
ZDDs of the projection functions change when new variables are added.
This will be discussed in Section&nbsp;<A HREF="node3.html#sec:basicZDD">3.9</A>. Here we assume
that the number of variables is fixed. The ZDD of the <I>i</I>-th
projection function is returned by <A NAME="tex2html41"
 HREF="cuddExtDet.html#Cudd_zddIthVar"><EM>  Cudd_zddIthVar</EM></A><A NAME="1489">&#160;</A>.

<P>

<H2><A NAME="SECTION00037000000000000000">&#160;</A>
<A NAME="339">&#160;</A><A NAME="sec:basicBDD">&#160;</A>
<BR>
Basic BDD Manipulation
</H2>

<P>
Common manipulations of BDDs can be accomplished by calling <A NAME="tex2html42"
 HREF="cuddExtDet.html#Cudd_bddIte"><EM>  Cudd_bddIte</EM></A>.  This function takes three BDDs, <I>f</I>, <I>g</I>, and <I>h</I>,
as arguments and computes 
<!-- MATH: $f\cdot g + f'\cdot h$ -->
<IMG
 WIDTH="84" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.gif"
 ALT="$f\cdot g + f'\cdot h$">.
Like all the
functions that create new BDDs or ADDs, <A NAME="tex2html43"
 HREF="cuddExtDet.html#Cudd_bddIte"><EM>  Cudd_bddIte</EM></A><A NAME="1491">&#160;</A> returns a result that must
be explicitly referenced by the caller. <A NAME="tex2html44"
 HREF="cuddExtDet.html#Cudd_bddIte"><EM>Cudd_bddIte</EM></A>
can be
used to implement all two-argument boolean functions. However, the
package also provides <A NAME="tex2html45"
 HREF="cuddExtDet.html#Cudd_bddAnd"><EM>Cudd_bddAnd</EM></A><A NAME="1493">&#160;</A>
as well as the other two-operand boolean functions, which are slightly
more efficient when a two-operand function is called for. The
following fragment of code illustrates how to build the BDD for the
function 
<!-- MATH: $f = x_0'x_1'x_2'x_3'$ -->
<I>f</I> = <I>x</I><SUB>0</SUB>'<I>x</I><SUB>1</SUB>'<I>x</I><SUB>2</SUB>'<I>x</I><SUB>3</SUB>'.
<PRE>
        DdManager *manager;
        DdNode *f, *var, *tmp;
        int i;

        ...

        f = Cudd_ReadOne(manager);
        Cudd_Ref(f);
        for (i = 3; i &gt;= 0; i--) {
            var = Cudd_bddIthVar(manager,i);
            tmp = Cudd_bddAnd(manager,Cudd_Not(var),f);
            Cudd_Ref(tmp);
            Cudd_RecursiveDeref(manager,f);
            f = tmp;
        }
</PRE>This example illustrates the following points:
<UL>
<LI>Intermediate results must be ``referenced" and ``dereferenced."

However, <TT>var</TT> is a projection<A NAME="355">&#160;</A>
  function, and its reference<A NAME="356">&#160;</A> count is always
  greater than 0. Therefore, there is no call to <A NAME="tex2html46"
 HREF="cuddExtDet.html#Cudd_Ref"><EM>    Cudd_Ref</EM></A><A NAME="1495">&#160;</A>.
<LI>The new <TT>f</TT> must be assigned to a temporary variable (<TT>    tmp</TT> in this example). If the result of <A NAME="tex2html47"
 HREF="cuddExtDet.html#Cudd_bddAnd"><EM>    Cudd_bddAnd</EM></A><A NAME="1497">&#160;</A> were assigned directly

to <TT>f</TT>, the old <TT>f</TT> would be lost, and there would be no way
  to free its nodes.
<LI>The statement <TT>f = tmp</TT> has the same effect as:
<PRE>
            f = tmp;
            Cudd_Ref(f);
            Cudd_RecursiveDeref(manager,tmp);
</PRE>  but is more efficient. The reference<A NAME="370">&#160;</A> is
  ``passed" from <TT>tmp</TT> to <TT>f</TT>, and <TT>tmp</TT> is now ready to
  be reutilized.
<LI>It is normally more efficient to build BDDs ``bottom-up." This
  is why the loop goes from 3 to 0. Notice, however, that after
  variable reordering, higher index does not necessarily mean ``closer
  to the bottom." Of course, in this simple example, efficiency is not
  a concern.
<LI>Had we wanted to conjoin the variables in a bottom-up fashion
  even after reordering, we should have used <A NAME="tex2html48"
 HREF="cuddExtDet.html#Cudd_ReadInvPerm"><EM>    Cudd_ReadInvPerm</EM></A><A NAME="1499">&#160;</A>.  One has to be

careful, though, to fix the order of conjunction before entering the
  loop. Otherwise, if reordering takes place, it is possible to use
  one variable twice and skip another variable.
</UL>
<P>

<H2><A NAME="SECTION00038000000000000000">&#160;</A>
<A NAME="379">&#160;</A><A NAME="sec:basicADD">&#160;</A>
<BR>
Basic ADD Manipulation
</H2>

<P>
The most common way to manipulate ADDs is via <A NAME="tex2html49"
 HREF="cuddExtDet.html#Cudd_addApply"><EM>  Cudd_addApply</EM></A><A NAME="1501">&#160;</A>.  This function can
apply a wide variety of operators to a pair of ADDs.  Among the
available operators are addition, multiplication, division, minimum,
maximum, and boolean operators that work on ADDs whose leaves are
restricted to 0 and 1 (0-1 ADDs).

<P>
The following fragment of code illustrates how to build the ADD for
the function 
<!-- MATH: $f = 5x_0x_1x_2x_3$ -->
<I>f</I> = 5<I>x</I><SUB>0</SUB><I>x</I><SUB>1</SUB><I>x</I><SUB>2</SUB><I>x</I><SUB>3</SUB>.
<PRE>
        DdManager *manager;
        DdNode *f, *var, *tmp;
        int i;

        ...

        f = Cudd_addConst(manager,5);
        Cudd_Ref(f);
        for (i = 3; i &gt;= 0; i--) {
            var = Cudd_addIthVar(manager,i);
            Cudd_Ref(var);
            tmp = Cudd_addApply(manager,Cudd_addTimes,var,f);
            Cudd_Ref(tmp);
            Cudd_RecursiveDeref(manager,f);
            Cudd_RecursiveDeref(manager,var);
            f = tmp;
        }
</PRE>This example, contrasted to the example of BDD manipulation,
illustrates the following points:
<UL>
<LI>The ADD projection<A NAME="387">&#160;</A> function are not
  maintained by the manager.  It is therefore necessary to
  reference<A NAME="388">&#160;</A> and
  dereference<A NAME="389">&#160;</A> them.
<LI>The product of two ADDs is computed by calling <A NAME="tex2html50"
 HREF="cuddExtDet.html#Cudd_addApply"><EM>    Cudd_addApply</EM></A><A NAME="1503">&#160;</A> with <A NAME="tex2html51"
 HREF="cuddExtDet.html#Cudd_addTimes"><EM>    Cudd_addTimes</EM></A><A NAME="1505">&#160;</A> as parameter.  There

is no ``apply'' function for BDDs, because <A NAME="tex2html52"
 HREF="cuddExtDet.html#Cudd_bddAnd"><EM>    Cudd_bddAnd</EM></A><A NAME="1507">&#160;</A> and <A NAME="tex2html53"
 HREF="cuddExtDet.html#Cudd_bddXor"><EM>    Cudd_bddXor</EM></A><A NAME="1509">&#160;</A> plus complementation are

sufficient to implement all two-argument boolean functions.
</UL>
<P>

<H2><A NAME="SECTION00039000000000000000">&#160;</A>
<A NAME="404">&#160;</A><A NAME="sec:basicZDD">&#160;</A>
<BR>
Basic ZDD Manipulation
</H2>

<P>
ZDDs are often generated by converting<A NAME="406">&#160;</A>
existing BDDs. (See Section&nbsp;<A HREF="node3.html#sec:convertZ">3.11</A>.) However, it is also
possible to build ZDDs by applying boolean operators to other ZDDs,
starting from constants and projection<A NAME="408">&#160;</A>
functions.  The following fragment of code illustrates how to build
the ZDD for the function 
<!-- MATH: $f = x_0'+x_1'+x_2'+x_3'$ -->
<I>f</I> = <I>x</I><SUB>0</SUB>'+<I>x</I><SUB>1</SUB>'+<I>x</I><SUB>2</SUB>'+<I>x</I><SUB>3</SUB>'. We assume that the
four variables already exist in the manager when the ZDD for <I>f</I> is
built. Note the use of De Morgan's law.
<PRE>
        DdManager *manager;
        DdNode *f, *var, *tmp;
        int i;

        manager = Cudd_Init(0,4,CUDD_UNIQUE_SLOTS,
                            CUDD_CACHE_SLOTS,0);
        ...

        tmp = Cudd_ReadZddOne(manager,0);
        Cudd_Ref(tmp);
        for (i = 3; i &gt;= 0; i--) {
            var = Cudd_zddIthVar(manager,i);
            Cudd_Ref(var);
            f = Cudd_zddIntersect(manager,var,tmp);
            Cudd_Ref(f);
            Cudd_RecursiveDerefZdd(manager,tmp);
            Cudd_RecursiveDerefZdd(manager,var);
            tmp = f;
        }
        f = Cudd_zddDiff(manager,Cudd_ReadZddOne(manager,0),tmp);
        Cudd_Ref(f);
        Cudd_RecursiveDerefZdd(manager,tmp);
</PRE>This example illustrates the following points:
<UL>
<LI>The projection<A NAME="412">&#160;</A> functions are
  referenced, because they are not maintained by the manager.
<LI>Complementation is obtained by subtracting from the constant 1
  function.
<LI>The result of <A NAME="tex2html54"
 HREF="cuddExtDet.html#Cudd_ReadZddOne"><EM>    Cudd_ReadZddOne</EM></A><A NAME="1511">&#160;</A> does not

require referencing.
</UL>CUDD provides functions for the manipulation of
covers<A NAME="417">&#160;</A> represented by ZDDs. For instance, <A NAME="tex2html55"
 HREF="cuddExtDet.html#Cudd_zddIsop"><EM>  Cudd_zddIsop</EM></A><A NAME="1513">&#160;</A> builds a ZDD
representing an irredundant<A NAME="421">&#160;</A> sum of
products for the incompletely specified function defined by the two
BDDs <I>L</I> and <I>U</I>. <A NAME="tex2html56"
 HREF="cuddExtDet.html#Cudd_zddWeakDiv"><EM>  Cudd_zddWeakDiv</EM></A><A NAME="1515">&#160;</A> performs the weak
division of two covers given as ZDDs.  These functions expect the two
ZDD variables corresponding to the two literals of the function variable
to be adjacent.  One has to create variable groups (see
Section&nbsp;<A HREF="node3.html#sec:reordZ">3.14</A>) for reordering<A NAME="426">&#160;</A> of
the ZDD variables to work.  BDD automatic reordering is safe even
without groups: If realignment of ZDD and ADD/BDD variables is requested
(see Section&nbsp;<A HREF="node3.html#sec:consist">3.15</A>) groups will be kept adjacent.

<P>

<H2><A NAME="SECTION000310000000000000000">&#160;</A>
<A NAME="429">&#160;</A>
<A NAME="430">&#160;</A><A NAME="sec:convert">&#160;</A>
<BR>
Converting ADDs to BDDs and Vice Versa
</H2>

<P>
Several procedures are provided to convert ADDs to BDDs, according to
different criteria. (<A NAME="tex2html57"
 HREF="cuddExtDet.html#Cudd_addBddPattern"><EM>  Cudd_addBddPattern</EM></A><A NAME="1517">&#160;</A>, <A NAME="tex2html58"
 HREF="cuddExtDet.html#Cudd_addBddInterval"><EM>  Cudd_addBddInterval</EM></A><A NAME="1519">&#160;</A>, and <A NAME="tex2html59"
 HREF="cuddExtDet.html#Cudd_addBddThreshold"><EM>  Cudd_addBddThreshold</EM></A><A NAME="1521">&#160;</A>.) The
conversion from BDDs to ADDs (<A NAME="tex2html60"
 HREF="cuddExtDet.html#Cudd_BddToAdd"><EM>  Cudd_BddToAdd</EM></A><A NAME="1523">&#160;</A>) is based on the
simple principle of mapping the logical 0<A NAME="444">&#160;</A> and 1 on
the arithmetic<A NAME="445">&#160;</A> 0 and 1.  It is also possible to
convert an ADD with integer values (more precisely, floating point
numbers with 0 fractional part) to an array of BDDs by repeatedly
calling <A NAME="tex2html61"
 HREF="cuddExtDet.html#Cudd_addIthBit"><EM>Cudd_addIthBit</EM></A><A NAME="1525">&#160;</A>.

<P>

<H2><A NAME="SECTION000311000000000000000">&#160;</A>
<A NAME="450">&#160;</A>
<A NAME="451">&#160;</A><A NAME="sec:convertZ">&#160;</A>
<BR>
Converting BDDs to ZDDs and Vice Versa
</H2>

<P>
Many applications first build a set of BDDs and then derive ZDDs from
the BDDs. These applications should create the manager with 0
ZDD<A NAME="453">&#160;</A> variables and
create the BDDs. Then they should call <A NAME="tex2html62"
 HREF="cuddExtDet.html#Cudd_zddVarsFromBddVars"><EM>  Cudd_zddVarsFromBddVars</EM></A><A NAME="1527">&#160;</A> to
create the necessary ZDD variables--whose number is likely to be
known once the BDDs are available.  This approach eliminates the
difficulties that arise when the number of ZDD variables changes while
ZDDs are being built.

<P>
The simplest conversion from BDDs to ZDDs is a simple change of
representation, which preserves the functions. Simply put, given a BDD
for <I>f</I>, a ZDD for <I>f</I> is requested. In this case the correspondence
between the BDD variables and ZDD variables is one-to-one. Hence, <A NAME="tex2html63"
 HREF="cuddExtDet.html#Cudd_zddVarsFromBddVars"><EM>  Cudd_zddVarsFromBddVars</EM></A>
should be called with the <EM>  multiplicity</EM> parameter equal to 1. The conversion proper can then
be performed by calling <A NAME="tex2html64"
 HREF="cuddExtDet.html#Cudd_zddPortFromBdd"><EM>  Cudd_zddPortFromBdd</EM></A><A NAME="1529">&#160;</A>. The
inverse transformation is performed by <A NAME="tex2html65"
 HREF="cuddExtDet.html#Cudd_zddPortToBdd"><EM>  Cudd_zddPortToBdd</EM></A><A NAME="1531">&#160;</A>.

<P>
ZDDs are quite often used for the representation of <EM>  covers</EM><A NAME="467">&#160;</A>. This is normally done by associating
two ZDD variables to each variable of the function. (And hence,
typically, to each BDD variable.) One ZDD variable is associated with
the positive literal of the BDD variable, while the other ZDD variable
is associated with the negative literal.  A call to <A NAME="tex2html66"
 HREF="cuddExtDet.html#Cudd_zddVarsFromBddVars"><EM>  Cudd_zddVarsFromBddVars</EM></A><A NAME="1533">&#160;</A>
with <EM>multiplicity</EM> equal to 2 will associate to BDD variable
<I>i</I> the two ZDD variables 2<I>i</I> and 2<I>i</I>+1.

<P>
If a BDD variable group tree exists when <A NAME="tex2html67"
 HREF="cuddExtDet.html#Cudd_zddVarsFromBddVars"><EM>  Cudd_zddVarsFromBddVars</EM></A>
is called (see Section&nbsp;<A HREF="node3.html#sec:group">3.13</A>)
the function generates a ZDD variable group tree consistent to it.  In
any case, all the ZDD variables derived from the same BDD variable are
clustered into a group.

<P>
If the ZDD for <I>f</I> is created and later a new ZDD variable is added to
the manager, the function represented by the existing ZDD changes.
Suppose, for instance, that two variables are initially created, and
that the ZDD for 
<!-- MATH: $f = x_0 + x_1$ -->
<I>f</I> = <I>x</I><SUB>0</SUB> + <I>x</I><SUB>1</SUB> is built. If a third variable is
added, say <I>x</I><SUB>2</SUB>, then the ZDD represents 
<!-- MATH: $g = (x_0 + x_1) x_2'$ -->
<I>g</I> = (<I>x</I><SUB>0</SUB> + <I>x</I><SUB>1</SUB>) <I>x</I><SUB>2</SUB>'instead.  This change in function obviously applies regardless of what
use is made of the ZDD. However, if the ZDD is used to represent a
cover<A NAME="475">&#160;</A>, the cover itself is not changed by the
addition of new variable. (What changes is the
characteristic<A NAME="476">&#160;</A> function of the cover.)

<P>

<H2><A NAME="SECTION000312000000000000000">&#160;</A>
<A NAME="478">&#160;</A><A NAME="sec:reorder">&#160;</A>
<BR>
Variable Reordering for BDDs and ADDs
</H2>

<P>
The CUDD package provides a rich set of
dynamic<A NAME="480">&#160;</A> reordering algorithms.  Some of them
are slight variations of existing techniques
[<A
 HREF="node7.html#Rudell93">16</A>,<A
 HREF="node7.html#Drechs95">6</A>,<A
 HREF="node7.html#Bollig95">2</A>,<A
 HREF="node7.html#Ishiur91">10</A>,<A
 HREF="node7.html#Plessi93">15</A>,<A
 HREF="node7.html#Jeong93">11</A>]; some
others have been developed specifically for this package
[<A
 HREF="node7.html#Panda94">14</A>,<A
 HREF="node7.html#Panda95b">13</A>].

<P>
Reordering affects a unique<A NAME="483">&#160;</A> table. This means that
BDDs and ADDs, which share the same unique table are simultaneously
reordered. ZDDs, on the other hand, are reordered separately. In the
following we discuss the reordering of BDDs and ADDs. Reordering for
ZDDs is the subject of Section&nbsp;<A HREF="node3.html#sec:reordZ">3.14</A>.

<P>
Reordering of the variables can be invoked directly by the application
by calling <A NAME="tex2html68"
 HREF="cuddExtDet.html#Cudd_ReduceHeap"><EM>Cudd_ReduceHeap</EM></A><A NAME="1535">&#160;</A>. Or it
can be automatically triggered by the package when the number of nodes
has reached a given threshold<A NAME="488">&#160;</A>.  (The
threshold is initialized and automatically adjusted after each
reordering by the package.) To enable automatic dynamic reordering
(also called <EM>asynchronous<A NAME="489">&#160;</A></EM>
dynamic reordering in this document) the application must call <A NAME="tex2html69"
 HREF="cuddExtDet.html#Cudd_AutodynEnable"><EM>  Cudd_AutodynEnable</EM></A><A NAME="1537">&#160;</A>.  Automatic
dynamic reordering can subsequently be disabled by calling <A NAME="tex2html70"
 HREF="cuddExtDet.html#Cudd_AutodynDisable"><EM>  Cudd_AutodynDisable</EM></A><A NAME="1539">&#160;</A>.

<P>
All reordering methods are available in both the case of direct call
to <A NAME="tex2html71"
 HREF="cuddExtDet.html#Cudd_ReduceHeap"><EM>Cudd_ReduceHeap</EM></A><A NAME="1541">&#160;</A> and the case of
automatic invocation. For many methods, the reordering procedure is
iterated until no further improvement is obtained. We call these
methods the <EM>converging<A NAME="499">&#160;</A></EM> methods.
When constraints are imposed on the relative position of variables
(see Section&nbsp;<A HREF="node3.html#sec:group">3.13</A>) the reordering methods apply inside the
groups. The groups<A NAME="501">&#160;</A> themselves are reordered by
sifting<A NAME="502">&#160;</A>.  Each method is identified by a
constant of the enumerated type <EM>  Cudd_ReorderingType<A NAME="503">&#160;</A></EM>
defined in <EM>cudd.h<A NAME="504">&#160;</A></EM> (the external
header<A NAME="505">&#160;</A> file of the CUDD package):

<P>
<DL>
<DT><STRONG>CUDD_REORDER_NONE<A NAME="507">&#160;</A>:</STRONG>
<DD>This method
causes no reordering.
<DT><STRONG>CUDD_REORDER_SAME<A NAME="508">&#160;</A>:</STRONG>
<DD>If passed to
  <A NAME="tex2html72"
 HREF="cuddExtDet.html#Cudd_AutodynEnable"><EM>Cudd_AutodynEnable</EM></A><A NAME="1543">&#160;</A>, this

method leaves the current method for automatic reordering unchanged.
  If passed to <A NAME="tex2html73"
 HREF="cuddExtDet.html#Cudd_ReduceHeap"><EM>Cudd_ReduceHeap</EM></A><A NAME="1545">&#160;</A>,

this method causes the current method for automatic reordering to be
  used.
<DT><STRONG>CUDD_REORDER_RANDOM<A NAME="515">&#160;</A>:</STRONG>
<DD>Pairs of
  variables are randomly chosen, and swapped in the order. The swap is
  performed by a series of swaps of adjacent variables. The best order
  among those obtained by the series of swaps is retained. The number
  of pairs chosen for swapping<A NAME="516">&#160;</A> equals the
  number of variables in the diagram.
<DT><STRONG>CUDD_REORDER_RANDOM_PIVOT<A NAME="517">&#160;</A>:</STRONG>
<DD>Same as CUDD_REORDER_RANDOM, but the two variables are chosen so
  that the first is above the variable with the largest number of
  nodes, and the second is below that variable.  In case there are
  several variables tied for the maximum number of nodes, the one
  closest to the root is used.
<DT><STRONG>CUDD_REORDER_SIFT<A NAME="518">&#160;</A>:</STRONG>
<DD>This method is
  an implementation of Rudell's sifting<A NAME="519">&#160;</A>
  algorithm [<A
 HREF="node7.html#Rudell93">16</A>]. A simplified description of sifting is as
  follows: Each variable is considered in turn. A variable is moved up
  and down in the order so that it takes all possible positions. The
  best position is identified and the variable is returned to that
  position.
  
  In reality, things are a bit more complicated. For instance, there
  is a limit on the number of variables that will be sifted. This
  limit can be read with <A NAME="tex2html74"
 HREF="cuddExtDet.html#Cudd_ReadSiftMaxVar"><EM>    Cudd_ReadSiftMaxVar</EM></A><A NAME="1547">&#160;</A> and set

with <A NAME="tex2html75"
 HREF="cuddExtDet.html#Cudd_SetSiftMaxVar"><EM>Cudd_SetSiftMaxVar</EM></A><A NAME="1549">&#160;</A>. In

addition, if the diagram grows too much while moving a variable up
  or down, that movement is terminated before the variable has reached
  one end of the order. The maximum ratio by which the diagram is
  allowed to grow while a variable is being sifted can be read with
  <A NAME="tex2html76"
 HREF="cuddExtDet.html#Cudd_ReadMaxGrowth"><EM>Cudd_ReadMaxGrowth</EM></A><A NAME="1551">&#160;</A> and

set with <A NAME="tex2html77"
 HREF="cuddExtDet.html#Cudd_SetMaxGrowth"><EM>Cudd_SetMaxGrowth</EM></A><A NAME="1553">&#160;</A>.
<DT><STRONG>CUDD_REORDER_SIFT_CONVERGE<A NAME="533">&#160;</A>:</STRONG>
<DD>This is the converging<A NAME="534">&#160;</A> variant of

CUDD_REORDER_SIFT.
<DT><STRONG>CUDD_REORDER_SYMM_SIFT<A NAME="535">&#160;</A>:</STRONG>
<DD>This method is an implementation of
  symmetric<A NAME="536">&#160;</A> sifting [<A
 HREF="node7.html#Panda94">14</A>]. It is
  similar to sifting, with one addition: Variables that become
  adjacent during sifting are tested for symmetry<A NAME="538">&#160;</A>. If
  they are symmetric, they are linked in a group.  Sifting then
  continues with a group being moved, instead of a single variable.
  After symmetric sifting has been run, <A NAME="tex2html78"
 HREF="cuddExtDet.html#Cudd_SymmProfile"><EM>    Cudd_SymmProfile</EM></A><A NAME="1555">&#160;</A> can be called

to report on the symmetry groups found. (Both positive and negative
  symmetries are reported.)
<DT><STRONG>CUDD_REORDER_SYMM_SIFT_CONV<A NAME="542">&#160;</A>:</STRONG>
<DD>This is the converging<A NAME="543">&#160;</A> variant of
  CUDD_REORDER_SYMM_SIFT.
<DT><STRONG>CUDD_REORDER_GROUP_SIFT<A NAME="544">&#160;</A>:</STRONG>
<DD>This method is an implementation of group<A NAME="545">&#160;</A>
  sifting [<A
 HREF="node7.html#Panda95b">13</A>]. It is similar to symmetric sifting, but
  aggregation<A NAME="547">&#160;</A> is not restricted to symmetric
  variables.
<DT><STRONG>CUDD_REORDER_GROUP_SIFT_CONV<A NAME="548">&#160;</A>:</STRONG>
<DD>This method repeats until convergence the combination of
  CUDD_REORDER_GROUP_SIFT and CUDD_REORDER_WINDOW4.
<DT><STRONG>CUDD_REORDER_WINDOW2<A NAME="549">&#160;</A>:</STRONG>
<DD>This
  method implements the window<A NAME="550">&#160;</A> permutation
  approach of Fujita [<A
 HREF="node7.html#Fujita91b">8</A>] and Ishiura [<A
 HREF="node7.html#Ishiur91">10</A>].
  The size of the window is 2.
<DT><STRONG>CUDD_REORDER_WINDOW3<A NAME="553">&#160;</A>:</STRONG>
<DD>Similar
  to CUDD_REORDER_WINDOW2, but with a window of size 3.
<DT><STRONG>CUDD_REORDER_WINDOW4<A NAME="554">&#160;</A>:</STRONG>
<DD>Similar
  to CUDD_REORDER_WINDOW2, but with a window of size 4.
<DT><STRONG>CUDD_REORDER_WINDOW2_CONV<A NAME="555">&#160;</A>:</STRONG>
<DD>This is the converging<A NAME="556">&#160;</A> variant of
  CUDD_REORDER_WINDOW2.
<DT><STRONG>CUDD_REORDER_WINDOW3_CONV<A NAME="557">&#160;</A>:</STRONG>
<DD>This is the converging variant of CUDD_REORDER_WINDOW3.
<DT><STRONG>CUDD_REORDER_WINDOW4_CONV<A NAME="558">&#160;</A>:</STRONG>
<DD>This is the converging variant of CUDD_REORDER_WINDOW4.
<DT><STRONG>CUDD_REORDER_ANNEALING<A NAME="559">&#160;</A>:</STRONG>
<DD>This
  method is an implementation of simulated
  annealing<A NAME="560">&#160;</A> for variable
  ordering, vaguely resemblant of the algorithm of [<A
 HREF="node7.html#Bollig95">2</A>].
  This method is potentially very slow.
<DT><STRONG>CUDD_REORDER_GENETIC:<A NAME="562">&#160;</A></STRONG>
<DD>This
  method is an implementation of a genetic<A NAME="563">&#160;</A>
  algorithm for variable ordering, inspired by the work of Drechsler
  [<A
 HREF="node7.html#Drechs95">6</A>]. This method is potentially very slow.
<DT><STRONG>CUDD_REORDER_EXACT<A NAME="565">&#160;</A>:</STRONG>
<DD>This method
  implements a dynamic programming approach to
  exact<A NAME="566">&#160;</A> reordering
  [<A
 HREF="node7.html#Held62">9</A>,<A
 HREF="node7.html#Friedman90">7</A>,<A
 HREF="node7.html#Ishiur91">10</A>], with improvements described in
  [<A
 HREF="node7.html#Jeong93">11</A>]. It only stores one BDD at the time. Therefore, it is
  relatively efficient in terms of memory.  Compared to other
  reordering strategies, it is very slow, and is not recommended for
  more than 16 variables.
</DL>So far we have described methods whereby the package selects an order
automatically. A given order of the variables can also be imposed by
calling <A NAME="tex2html79"
 HREF="cuddExtDet.html#Cudd_ShuffleHeap"><EM>Cudd_ShuffleHeap</EM></A><A NAME="1557">&#160;</A>.

<P>

<H2><A NAME="SECTION000313000000000000000">&#160;</A>
<A NAME="574">&#160;</A><A NAME="sec:group">&#160;</A>
<BR>
Grouping Variables
</H2>

<P>
CUDD allows the application to specify constraints on the positions of
group of variables. It is possible to request that a group of
contiguous variables be kept contiguous by the reordering procedures.
It is also possible to request that the relative order of some groups
of variables be left unchanged. The constraints on the order are
specified by means of a tree<A NAME="576">&#160;</A>, which is created in
one of two ways:
<UL>
<LI>By calling <A NAME="tex2html80"
 HREF="cuddExtDet.html#Cudd_MakeTreeNode"><EM>Cudd_MakeTreeNode</EM></A><A NAME="1559">&#160;</A>.
<LI>By calling the functions of the MTR<A NAME="581">&#160;</A> library

(part of the distribution), and by registering the result with the
  manager using <A NAME="tex2html81"
 HREF="cuddExtDet.html#Cudd_SetTree"><EM>Cudd_SetTree</EM></A><A NAME="1561">&#160;</A>. The

current tree registered with the manager can be read with <A NAME="tex2html82"
 HREF="cuddExtDet.html#Cudd_ReadTree"><EM>    Cudd_ReadTree</EM></A><A NAME="1563">&#160;</A>.
</UL>
<P>
Each node in the tree represents a range of variables. The lower bound
of the range is given by the <EM>low</EM> field of the node, and the
size of the group is given by the <EM>size</EM> field of the
node.<A NAME="tex2html83"
 HREF="footnode.html#foot1311"><SUP>2</SUP></A>  The variables in
each range are kept contiguous. Furthermore, if a node is marked with
the MTR_FIXED<A NAME="593">&#160;</A> flag, then the relative order of the
variable ranges associated to its children is not changed.  As an
example, suppose the initial variable order is:
<PRE>
        x0, y0, z0, x1, y1, z1, ... , x9, y9, z9.
</PRE>Suppose we want to keep each group of three variables with the same
index (e.g., <code>x3, y3, z3</code>) contiguous, while allowing the package
to change the order of the groups. We can accomplish this with the
following code:
<PRE>
        for (i = 0; i &lt; 10; i++) {
            (void) Cudd_MakeTreeNode(manager,i*3,3,MTR_DEFAULT);
        }
</PRE>If we want to keep the order within each group of variables
fixed (i.e., <code>x</code> before <code>y</code> before <code>z</code>) we need to
change MTR_DEFAULT<A NAME="598">&#160;</A> into MTR_FIXED.

<P>
The <EM>low</EM> parameter passed to <A NAME="tex2html84"
 HREF="cuddExtDet.html#Cudd_MakeTreeNode"><EM>  Cudd_MakeTreeNode</EM></A><A NAME="1565">&#160;</A> is the index
of a variable (as opposed to its level or position in the order).  The
group tree<A NAME="603">&#160;</A> can be created at any time. The result
obviously depends on the variable order in effect at creation time.

<P>
It is possible to create a variable group tree also before the
variables themselves are created. The package assumes in this case
that the index of the variables not yet in existence will equal their
position in the order when they are created. Therefore, applications
that rely on <A NAME="tex2html85"
 HREF="cuddExtDet.html#Cudd_bddNewVarAtLevel"><EM>  Cudd_bddNewVarAtLevel</EM></A><A NAME="1567">&#160;</A> or
<A NAME="tex2html86"
 HREF="cuddExtDet.html#Cudd_addNewVarAtLevel"><EM>Cudd_addNewVarAtLevel</EM></A><A NAME="1569">&#160;</A> to
create new variables have to create the variables before they group
them.

<P>
The reordering procedure will skip all groups whose variables are not
yet in existence. For groups that are only partially in existence, the
reordering procedure will try to reorder the variables already
instantiated, without violating the adjacency constraints.

<P>

<H2><A NAME="SECTION000314000000000000000">&#160;</A>
<A NAME="611">&#160;</A><A NAME="sec:reordZ">&#160;</A>
<BR>
Variable Reordering for ZDDs
</H2>

<P>
Reordering of ZDDs is done in much the same way as the reordering of
BDDs and ADDs. The functions corresponding to <A NAME="tex2html87"
 HREF="cuddExtDet.html#Cudd_ReduceHeap"><EM>Cudd_ReduceHeap</EM></A>
and <A NAME="tex2html88"
 HREF="cuddExtDet.html#Cudd_ShuffleHeap"><EM>Cudd_ShuffleHeap</EM></A>
are <A NAME="tex2html89"
 HREF="cuddExtDet.html#Cudd_zddReduceHeap"><EM>  Cudd_zddReduceHeap</EM></A><A NAME="1571">&#160;</A> and <A NAME="tex2html90"
 HREF="cuddExtDet.html#Cudd_zddShuffleHeap"><EM>  Cudd_zddShuffleHeap</EM></A><A NAME="1573">&#160;</A>. To enable
dynamic<A NAME="623">&#160;</A> reordering, the application must
call <A NAME="tex2html91"
 HREF="cuddExtDet.html#Cudd_AutodynEnableZdd"><EM>Cudd_AutodynEnableZdd</EM></A><A NAME="1575">&#160;</A>,
and to disable dynamic reordering, it must call <A NAME="tex2html92"
 HREF="cuddExtDet.html#Cudd_AutodynDisableZdd"><EM>  Cudd_AutodynDisableZdd</EM></A><A NAME="1577">&#160;</A>.  In
the current implementation, however, the choice of reordering methods
for ZDDs is more limited. Specifically, these methods are available:

<P>
<DL>
<DT><STRONG>CUDD_REORDER_NONE<A NAME="631">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_SAME<A NAME="632">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_RANDOM<A NAME="633">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_RANDOM_PIVOT<A NAME="634">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_SIFT<A NAME="635">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_SIFT_CONVERGE<A NAME="636">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_SYMM_SIFT<A NAME="637">&#160;</A>;</STRONG>
<DD><DT><STRONG>CUDD_REORDER_SYMM_SIFT_CONV<A NAME="638">&#160;</A>.</STRONG>
<DD></DL>
<P>
To create ZDD variable groups, the application calls <A NAME="tex2html93"
 HREF="cuddExtDet.html#Cudd_MakeZddTreeNode"><EM>  Cudd_MakeZddTreeNode</EM></A><A NAME="1579">&#160;</A>.

<P>

<H2><A NAME="SECTION000315000000000000000">&#160;</A>
<A NAME="sec:consist">&#160;</A>
<BR>
Keeping Consistent Variable Orders for BDDs and ZDDs
</H2>

<P>
Several applications that manipulate both BDDs and ZDDs benefit from
keeping a fixed correspondence between the order of the BDD variables
and the order of the ZDD variables. If each BDD variable corresponds
to a group of ZDD variables, then it is often desirable that the
groups of ZDD variables be in the same order as the corresponding BDD
variables. CUDD allows the ZDD order to
track the BDD order and vice versa. To have the ZDD order track
the BDD order, the application calls <A NAME="tex2html94"
 HREF="cuddExtDet.html#Cudd_zddRealignEnable"><EM>  Cudd_zddRealignEnable</EM></A><A NAME="1581">&#160;</A>. The
effect of this call can be reversed by calling <A NAME="tex2html95"
 HREF="cuddExtDet.html#Cudd_zddRealignDisable"><EM>  Cudd_zddRealignDisable</EM></A><A NAME="1583">&#160;</A>. When
ZDD realignment is in effect, automatic reordering of ZDDs should be
disabled.

<P>

<H2><A NAME="SECTION000316000000000000000">&#160;</A>
<A NAME="652">&#160;</A><A NAME="sec:hooks">&#160;</A>
<BR>
Hooks
</H2>

<P>
Hooks in CUDD are lists of application-specified functions to be run on
certain occasions. Each hook is identified by a constant of the
enumerated type <A NAME="tex2html96"
 HREF="cuddExtDet.html#Cudd_HookType"><EM>Cudd_HookType</EM></A><A NAME="1585">&#160;</A>. In Version
2.3.1 hooks are defined for these occasions:
<UL>
<LI>before garbage collection (CUDD_PRE_GC_HOOK);
<LI>after garbage collection (CDD_POST_GC_HOOK);
<LI>before variable reordering (CDD_PRE_REORDERING_HOOK).
<LI>after variable reordering (CDD_POST_REORDERING_HOOK).
</UL>The current implementation of hooks is experimental and the number of
hooks is likely to increase in the future. A function added to a hook
receives a pointer to the manager, a pointer to a string, and a
pointer to void as arguments; it must return 1 if successful; 0
otherwise. The second argument is either ``BDD'' or ``ZDD.'' This
allows the hook functions to tell the type of diagram for which
reordering or garbage collection takes place. The third argument
varies depending on the hook. The hook functions called before or
after garbage collection<A NAME="659">&#160;</A> do not use
it. The hook functions called before
reordering<A NAME="660">&#160;</A> are passed, in addition to the
pointer to the manager, also the method used for reordering. The hook
functions called after reordering are passed the start time. To add a
function to a hook, one uses <A NAME="tex2html97"
 HREF="cuddExtDet.html#Cudd_AddHook"><EM>  Cudd_AddHook</EM></A><A NAME="1587">&#160;</A>. The function of a given hook
are called in the order in which they were added to the hook.

<P>

<H2><A NAME="SECTION000317000000000000000">&#160;</A>
<A NAME="665">&#160;</A><A NAME="666">&#160;</A><A NAME="sec:sis-vis">&#160;</A>
<BR>
The SIS/VIS Interface
</H2>

<P>
The CUDD package contains interface functions that emulate the
behavior of the original BDD package used in SIS [<A
 HREF="node7.html#Sentov92">17</A>] and
in the newer
<A NAME="tex2html98"
 HREF="http://vlsi.Colorado.EDU/~vis/">VIS</A>
[<A
 HREF="node7.html#VIS">4</A>]. How to build VIS with CUDD is described
in the installation documents of VIS. (Version 1.1 and later.)

<P>

<H3><A NAME="SECTION000317100000000000000">&#160;</A>
<A NAME="673">&#160;</A><A NAME="sec:sis">&#160;</A>
<BR>
Using the CUDD Package in SIS
</H3>

<P>
This section describes how to build SIS with the CUDD package.  Let
<TT>SISDIR<A NAME="675">&#160;</A></TT> designate the root of the directory
hierarchy where the sources for SIS reside. Let <TT>  CUDDDIR<A NAME="676">&#160;</A></TT> be the root of the directory hierarchy where
the distribution of the CUDD package resides.  To build SIS with the
CUDD package, follow these steps.
<DL COMPACT>
<DT>1.
<DD>Create directories <TT>SISDIR/sis/cudd</TT> and <TT>    SISDIR/sis/mtr</TT>.
<DT>2.
<DD>Copy all files from <TT>CUDDDIR/cudd</TT> and <TT>CUDDDIR/sis</TT> to
<TT>SISDIR/sis/cudd</TT> and all files from <TT>CUDDDIR/mtr</TT> to <TT>  SISDIR/sis/mtr</TT>.
<DT>3.
<DD>Copy <TT>CUDDDIR/cudd/doc/cudd.doc</TT> to <TT>SISDIR/sis/cudd</TT>;
  also copy <TT>CUDDDIR/mtr/doc/mtr.doc</TT> to <TT>SISDIR/sis/mtr</TT>.
<DT>4.
<DD>In <TT>SISDIR/sis/cudd</TT> make <TT>bdd.h</TT> a symbolic link to
  <TT>cuddBdd.h</TT>. (That is: <TT>ln -s cuddBdd.h bdd.h</TT>.)
<DT>5.
<DD>In <TT>SISDIR/sis/cudd</TT> delete <TT>Makefile</TT> and rename <TT>    Makefile.sis</TT> as <TT>Makefile</TT>. Do the same in <TT>    SISDIR/sis/mtr</TT>.
<DT>6.
<DD>Copy <TT>CUDDDIR/sis/st.[ch]</TT> and <TT>CUDDDIR/st/doc/st.doc</TT>
  to <TT>SISDIR/sis/st</TT>. (This will overwrite the original files: You
  may want to save them beforehand.)
<DT>7.
<DD>From <TT>CUDDDIR/util</TT> copy <TT>datalimit.c</TT>
  to <TT>SISDIR/sis/util</TT>. Update <TT>util.h</TT> and <TT>Makefile</TT>
  in <TT>SISDIR/sis/util</TT>. Specifically, add the declaration
  <TT>EXTERN long getSoftDataLimit();</TT> to <TT>util.h</TT> and add
  <TT>datalimit.c</TT> to the list of source files (PSRC) in <TT>Makefile</TT>.
<DT>8.
<DD>In <TT>SISDIR/sis</TT> remove the link from <TT>bdd</TT> to <TT>    bdd_cmu</TT> or <TT>bdd_ucb</TT> (that is, <TT>rm bdd</TT>) and make <TT>    bdd</TT> a symbolic link to <TT>cudd</TT>.  (That is: <TT>ln -s cudd
    bdd</TT>.)
<DT>9.
<DD>Still in <TT>SISDIR/sis</TT>, edit <TT>Makefile</TT>, <TT>    Makefile.oct</TT>, and <TT>Makefile.nooct</TT>. In all three files add
  mtr to the list of directories to be made (DIRS).
<DT>10.
<DD>In <TT>SISDIR/sis/include</TT> make <TT>mtr.h</TT> a symbolic link to
  <TT>../mtr/mtr.h</TT>.
<DT>11.
<DD>In <TT>SISDIR/sis/doc</TT> make <TT>cudd.doc</TT> a symbolic link to
  <TT>../cudd/cudd.doc</TT> and <TT>mtr.doc</TT> a symbolic link to <TT>    ../mtr/mtr.doc</TT>. (That is: <TT>ln -s ../cudd/cudd.doc .; ln -s
    ../mtr/mtr.doc .</TT>.)
<DT>12.
<DD>From <TT>SISDIR</TT> do <TT>make clean</TT> followed by <TT>make -i</TT>.
  This should create a working copy of SIS that uses the CUDD package.
</DL>
<P>
The replacement for the <TT>st</TT> library is because the version
shipped with the CUDD package tests for out-of-memory conditions.
Notice that the version of the <TT>st</TT> library to be used for
replacement is not the one used for the normal build, because the
latter has been modified for C++ compatibility. The above installation
procedure has been tested on SIS 1.3. SIS can be obtained via
anonymous FTP<A NAME="738">&#160;</A> from <A NAME="tex2html99"
 HREF="ftp://ic.eecs.berkeley.edu"><TT>    ic.eecs.berkeley.edu</TT></A>.  To build SIS
1.3, you need <TT>sis-1.2.tar.Z</TT> and <TT>sis-1.2.patch1.Z</TT>. When
compiling on a DEC Alpha<A NAME="743">&#160;</A>, you should add the <TT>  -ieee_with_no_inexact</TT> flag. (See
Section&nbsp;<A HREF="node3.html#sec:predef-const">3.5.2</A>.) Refer to the <TT>Makefile</TT> in the
top level directory of the distribution for how to compile with 32-bit
pointers.

<P>

<H2><A NAME="SECTION000318000000000000000">&#160;</A>
<A NAME="sec:dump">&#160;</A>
<BR>
Writing Decision Diagrams to a File
</H2>

<P>
The CUDD package provides several functions to write decision diagrams
to a file. <A NAME="tex2html101"
 HREF="cuddExtDet.html#Cudd_DumpBlif"><EM>Cudd_DumpBlif</EM></A><A NAME="1589">&#160;</A> writes a
file in <EM>blif</EM> format.  It is restricted to BDDs. The diagrams
are written as a network of multiplexers, one multiplexer for each
internal node of the BDD.

<P>
<A NAME="tex2html102"
 HREF="cuddExtDet.html#Cudd_DumpDot"><EM>Cudd_DumpDot</EM></A><A NAME="1591">&#160;</A> produces input suitable to
the graph-drawing<A NAME="756">&#160;</A> program
<A NAME="tex2html103"
 HREF="http://www.research.att.com/sw/tools/reuse"><EM>dot</EM></A>
written by
Eleftherios Koutsofios and Stephen C. North. An example of drawing
produced by dot from the output of <A NAME="tex2html104"
 HREF="cuddExtDet.html#Cudd_DumpDot"><EM>Cudd_DumpDot</EM></A>
is shown in
Figure&nbsp;<A HREF="node3.html#fi:phase">1</A>. It is restricted to BDDs and ADDs.
<BR>
<DIV ALIGN="CENTER"><A NAME="fi:phase">&#160;</A><A NAME="1335">&#160;</A>
<TABLE WIDTH="50%">
<CAPTION><STRONG>Figure 1:</STRONG>
A BDD representing a phase constraint for the optimization of

fixed-polarity Reed-Muller forms. The label of each node is the
  unique part of the node address. All nodes on the same level
  correspond to the same variable, whose name is shown at the left of
  the diagram. Dotted lines indicate complement<A NAME="764">&#160;</A>
  arcs. Dashed lines indicate regular<A NAME="765">&#160;</A> ``else"
  arcs.</CAPTION>
<TR><TD><IMG
 WIDTH="429" HEIGHT="701"
 SRC="img5.gif"
 ALT="\begin{figure}\centerline{\epsfig{file=phase.ps,height=15.5cm}}\end{figure}"></TD></TR>
</TABLE>
</DIV>
<BR><A NAME="tex2html105"
 HREF="cuddExtDet.html#Cudd_zddDumpDot"><EM>Cudd_zddDumpDot</EM></A><A NAME="1593">&#160;</A> is the analog of <A NAME="tex2html106"
 HREF="cuddExtDet.html#Cudd_DumpDot"><EM>  Cudd_DumpDot</EM></A>
for ZDDs.

<P>
<A NAME="tex2html107"
 HREF="cuddExtDet.html#Cudd_DumpDaVinci"><EM>Cudd_DumpDaVinci</EM></A><A NAME="1595">&#160;</A> produces input suitable to
the graph-drawing<A NAME="776">&#160;</A> program
<A NAME="tex2html108"
 HREF="ftp://ftp.uni-bremen.de/pub/graphics/daVinci"><EM>    daVinci</EM></A>
developed
at the University of Bremen. It is  restricted to BDDs and ADDs.

<P>
Functions are also available to produce the input format of <EM>  DDcal</EM> (see Section&nbsp;<A HREF="node2.html#sec:getFriends">2.2</A>) and factored forms.

<P>

<H2><A NAME="SECTION000319000000000000000">&#160;</A>
<A NAME="sec:save-restore">&#160;</A>
<BR>
Saving and Restoring BDDs
</H2>

<P>
The <A NAME="tex2html109"
 HREF="ftp://ftp.polito.it/pub/research/dddmp/"><EM>dddmp</EM></A>
library<A NAME="785">&#160;</A> by Gianpiero Cabodi and
Stefano Quer allows a CUDD application to save BDDs to disk in compact
form for later retrieval. See the library's own documentation for the
details.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html268"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="icons/next_motif.gif"></A> 
<A NAME="tex2html265"
 HREF="cuddIntro.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="icons/up_motif.gif"></A> 
<A NAME="tex2html259"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="icons/previous_motif.gif"></A>  
<A NAME="tex2html267"
 HREF="node8.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="icons/index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html269"
 HREF="node4.html">Programmer's Manual</A>
<B> Up:</B> <A NAME="tex2html266"
 HREF="cuddIntro.html">CUDD: CU Decision Diagram</A>
<B> Previous:</B> <A NAME="tex2html260"
 HREF="node2.html">How to Get CUDD</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Fabio Somenzi</I>
<BR><I>2001-02-16</I>
</ADDRESS>
</BODY>
</HTML>
