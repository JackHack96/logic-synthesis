/**CFile****************************************************************

  FileName    [auDot.c]

  PackageName [MVSIS 1.3: Multi-valued logic synthesis system.]

  Synopsis    [Outputs of the STG of automata into DOT files to be 
  interpreted by DOT software from ATT reseach lab. 
  This software creates PostScript, which can be viewed or printed. 
  http://www.research.att.com/sw/tools/graphviz/ ]

  Author      [MVSIS Group]
  
  Affiliation [UC Berkeley]

  Date        [Ver. 1.0. Started - February 1, 2003.]

  Revision    [$Id: auDot.c,v 1.1 2004/02/19 03:06:45 alanmi Exp $]

***********************************************************************/

#include "auInt.h"

////////////////////////////////////////////////////////////////////////
///                        DECLARATIONS                              ///
////////////////////////////////////////////////////////////////////////

static void Au_AutoDotGetCondText( FILE * pFile, Mvc_Cover_t * pMvc );


////////////////////////////////////////////////////////////////////////
///                     FUNCTION DEFITIONS                           ///
////////////////////////////////////////////////////////////////////////

/**Function*************************************************************

  Synopsis    [Writes the STG of the automaton into the DOT file.]

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
void Au_AutoWriteDot( Au_Auto_t * pAut, char * pFileName, int nStatesMax, int fShowCond )
{
    Au_Trans_t * pTrans;
    FILE * pFile;
    int nLevels, Level, s;
	time_t ltime;
	char * TimeStamp;
    char Buffer1[20], Buffer2[20];
    int nStatesIncomp, nStatesNonDet;

    if ( pAut->nStates > nStatesMax )
    {
        printf( "The automaton has more than %d states. DOT file is not written.\n", nStatesMax );
        return;
    }

	// get the current time
	time( &ltime );
	TimeStamp = asctime( localtime( &ltime ) );
	TimeStamp[ strlen(TimeStamp) - 1 ] = 0;

    // perform the reachability analysis and set the level of the states
    nLevels = Au_AutoReachability( pAut, 0 );

    // start the stream
	pFile = fopen( pFileName, "w" );

	// write the DOT header
	fprintf( pFile, "# %s\n",  "Automaton generated by Au_AutoWriteDot() procedure in MVSIS 2.0." );
	fprintf( pFile, "\n" );
	fprintf( pFile, "digraph Automaton {\n" );
	fprintf( pFile, "size = \"7.5,10\";\n" );
//	fprintf( pFile, "ranksep = 0.5;\n" );
//	fprintf( pFile, "nodesep = 0.5;\n" );
	fprintf( pFile, "center = true;\n" );
    fprintf( pFile, "edge [fontsize = 10];\n" );
//	fprintf( pFile, "edge [dir = none];\n" );
	fprintf( pFile, "\n" );

	// labels on the left of the picture
	fprintf( pFile, "{\n" );
	fprintf( pFile, "  node [shape = plaintext];\n" );
	fprintf( pFile, "  edge [style = invis];\n" );
	fprintf( pFile, "  LevelTitle1 [label=\"\"];\n" );
	fprintf( pFile, "  LevelTitle2 [label=\"\"];\n" );
	// genetate node names with labels
	for ( Level = 0; Level <= nLevels; Level++ )
	{
		// the visible node name
		fprintf( pFile, "  Level%d", Level );
		fprintf( pFile, " [label = " );
		// label name
		fprintf( pFile, "\"" );
//        if ( Level != nLevels )
//		    fprintf( pFile, "%d", Level+1 );
		fprintf( pFile, "\"" );
		fprintf( pFile, "];\n" );
	}

	fprintf( pFile, "  LevelTitle1 ->  LevelTitle2 ->" );
	// genetate the sequence of visible/invisible nodes to mark levels
	for ( Level = 0; Level <= nLevels; Level++ )
	{
		// the visible node name
		fprintf( pFile, "  Level%d",  Level );
		// the connector
		if ( Level != nLevels )
			fprintf( pFile, " ->" );
		else
			fprintf( pFile, ";" );
	}
	fprintf( pFile, "\n" );
	fprintf( pFile, "}" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );

	// generate title box on top
	fprintf( pFile, "{\n" );
	fprintf( pFile, "  rank = same;\n" );
	fprintf( pFile, "  LevelTitle1;\n" );
	fprintf( pFile, "  title1 [shape=plaintext,\n" );
	fprintf( pFile, "          fontsize=20,\n" );
	fprintf( pFile, "          fontname = \"Times-Roman\",\n" );
	fprintf( pFile, "          label=\"" );
	fprintf( pFile, "%s", "Automaton generated by MVSIS 2.0." );
	fprintf( pFile, "\\n" );
	fprintf( pFile, "Benchmark \\\"%s\\\". ", pAut->pName );
	fprintf( pFile, "Time was %s. ",  TimeStamp );
	fprintf( pFile, "\"\n" );
	fprintf( pFile, "         ];\n" );
	fprintf( pFile, "}" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );

	// generate statistics box
	fprintf( pFile, "{\n" );
	fprintf( pFile, "  rank = same;\n" );
	fprintf( pFile, "  LevelTitle2;\n" );
	fprintf( pFile, "  title2 [shape=plaintext,\n" );
	fprintf( pFile, "          fontsize=18,\n" );
	fprintf( pFile, "          fontname = \"Times-Roman\",\n" );
	fprintf( pFile, "          label=\"" );
//	fprintf( pFile, "Inputs = %d. ",      pAut->nInputs );
//  fprintf( pFile, "Outputs = %d. ",     pAut->nOutputs );

//	fprintf( pFile, "The automaton is %s and %s.",  
//        (Au_AutoComplete( pAut, pAut->nInputs, 0, 1 )? "incomplete": "complete"),
//        (Au_AutoCheckNd( stdout, pAut, pAut->nInputs, 0 )? "non-deterministic": "deterministic") );

    nStatesIncomp = Au_AutoComplete( pAut, pAut->nInputs, 0, 1 );
    nStatesNonDet = Au_AutoCheckNd( stdout, pAut, pAut->nInputs, 0 );
    sprintf( Buffer1, " (%d states)", nStatesIncomp );
    sprintf( Buffer2, " (%d states)", nStatesNonDet );

	fprintf( pFile, "The automaton is %s%s and %s%s.", 
        (nStatesIncomp? "incomplete" : "complete"),
        (nStatesIncomp? Buffer1 : ""),
        (nStatesNonDet? "non-deterministic": "deterministic"),
        (nStatesNonDet? Buffer2 : "")     );

    fprintf( pFile, "\\n" );

    fprintf( pFile, "%d inputs  ",       pAut->nInputs );
	fprintf( pFile, "%d states  ",       pAut->nStates );
	fprintf( pFile, "%d transitions  ",  Au_AutoCountTransitions(pAut) );
	fprintf( pFile, "%d products",       Au_AutoCountProducts(pAut) );
	fprintf( pFile, "\\n" );

    fprintf( pFile, "Inputs = {", pAut->nInputs );
    for ( s = 0; s < pAut->nInputs; s++ )
        fprintf( pFile, "%s %s", ((s==0)? "": ","),  pAut->ppNamesInput[s] );
    fprintf( pFile, " }" );
	fprintf( pFile, "\\n" );

	fprintf( pFile, "\"\n" );
	fprintf( pFile, "         ];\n" );
	fprintf( pFile, "}" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );
/*
	// generate the square node on top
	fprintf( pFile, "{\n" );
	fprintf( pFile, "  rank = same;\n" );
	fprintf( pFile, "  node [shape=polygon, sides=7, peripheries=3];\n" );
	fprintf( pFile, "  edge [style = invis];\n" );
	for ( out = 0; out < pNet->nRoots; out++ )
		fprintf( pFile, "  title3_%d [label=\"%s\"];\n", out, pOutputs[out] );
	fprintf( pFile, "}" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );
*/
/*
	// generate nodes of each rank
	for ( Level = 0; Level < nLevels; Level++ )
	{
	    fprintf( pFile, "{\n" );
	    fprintf( pFile, "  rank = same;\n" );
//		fprintf( pFile, "  node [shape=record,width=1,height=0.75];\n" );
		fprintf( pFile, "  node [shape = circle];\n" );
		// the labeling node of this level
		fprintf( pFile, "  Level%d;\n",  Level );

//        for ( s = 0; s < pAut->nStates; s++ )
//            if ( pAut->pStates[s]->Level == Level && !pAut->pStates[s]->fRankLess )
//		        fprintf( pFile, "  Node%d [label = \"%s\"];\n", s, pAut->pStates[s]->pName );

		fprintf( pFile, "}" );
		fprintf( pFile, "\n" );
		fprintf( pFile, "\n" );
	}

    // put the unreachable states
    {
	    fprintf( pFile, "{\n" );
	    fprintf( pFile, "  rank = same;\n" );
//		fprintf( pFile, "  node [shape=record,width=1,height=0.75];\n" );
		fprintf( pFile, "  node [shape = circle];\n" );
		// the labeling node of this level
		fprintf( pFile, "  Level%d;\n",  nLevels );

//        for ( s = 0; s < pAut->nStates; s++ )
//            if ( pAut->pStates[s]->Level == UNREACHABLE && !pAut->pStates[s]->fRankLess )
//		        fprintf( pFile, "  Node%d [label = \"%s\"];\n", s, pAut->pStates[s]->pName );

		fprintf( pFile, "}" );
		fprintf( pFile, "\n" );
		fprintf( pFile, "\n" );
    }
*/

    {
		fprintf( pFile, "{\n" );
   	    fprintf( pFile, "  node [fixedsize = true];\n" );
	    fprintf( pFile, "  node [fontsize = 14];\n" );
//		fprintf( pFile, "  node [shape = circle];\n" );
		fprintf( pFile, "  node [hight = 0.7];\n" );
		fprintf( pFile, "  node [width = 1.0];\n" );
//		fprintf( pFile, "  node [style = bold];\n" );

        // print the nodes
        for ( s = 0; s < pAut->nStates; s++ )
        {
	        fprintf( pFile, "  Node%d [style=filled, label = \"%s\"", s, pAut->pStates[s]->pName );
            fprintf( pFile, "%s", (s == 0? ", shape = octagon": "") );
//            fprintf( pFile, "%s", (pAut->pStates[s]->fAcc? ", style = bold": "") );
            fprintf( pFile, "%s", (pAut->pStates[s]->fAcc? ", color = \".3 .7 1.0\", fillcolor = \".3 .7 1.0\"": ", color = coral, fillcolor = coral") );
	        fprintf( pFile, "];\n" );
        }

		fprintf( pFile, "}" );
		fprintf( pFile, "\n" );
		fprintf( pFile, "\n" );
    }
	
	// generate invisible edges from the square down
	fprintf( pFile, "title1 -> title2 [style = invis];\n" );
    fprintf( pFile, "title2 -> Node0 [style = invis];\n" );

	// generate edges
    for ( s = 0; s < pAut->nStates; s++ )
        Au_StateForEachTransition( pAut->pStates[s], pTrans )
        {
    		// generate the edge from this node to the next (or input variable)
			fprintf( pFile, "Node%d",  pTrans->StateCur );
			fprintf( pFile, " -> " );
			fprintf( pFile, "Node%d",  pTrans->StateNext );
            if ( fShowCond )
            {
			    fprintf( pFile, " [label = \"" );
                Au_AutoDotGetCondText( pFile, pTrans->pCond );
			    fprintf( pFile, "\"]" );
            }
			fprintf( pFile, ";\n" );
        }

	fprintf( pFile, "}" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );
	fclose( pFile );
}

/**Function*************************************************************

  Synopsis    [Performs reachability analysis.]

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
void Au_AutoDotGetCondText( FILE * pFile, Mvc_Cover_t * pMvc )
{
    Mvc_Cube_t * pCube;
    int Value0, Value1, v;
    int fFirst;

    fFirst = 1;
    Mvc_CoverForEachCube( pMvc, pCube )
    {
        if ( fFirst )
            fFirst = 0;
        else
            fprintf( pFile, "\\n" );
        for ( v = 0; v < pMvc->nBits/2; v++ )
        {
            Value0 = Mvc_CubeBitValue( pCube, 2*v );
            Value1 = Mvc_CubeBitValue( pCube, 2*v + 1 );
            if ( Value0 && Value1 )
                fprintf( pFile, "-" );
            else if ( Value0 && !Value1 )
                fprintf( pFile, "0" );
            else if ( !Value0 && Value1 )
                fprintf( pFile, "1" );
            else
            {
                assert( 0 );
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////
///                       END OF FILE                                ///
////////////////////////////////////////////////////////////////////////


