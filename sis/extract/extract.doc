/*
 * Revision Control Information
 *
 * $Source: /users/pchong/CVS/sis/sis/extract/extract.doc,v $
 * $Author: pchong $
 * $Revision: 1.1.1.1 $
 * $Date: 2004/02/07 10:14:22 $
 *
 */
ex_kernel_gen(node, func, state)
node_t *node;
int (*func)();
char *state;

	Calls the users function `func' once for each kernel of the function
	`node'.  `state' is passed along to contain user-defined state
	information during generation.  The function func is declared as:

	    int
	    func(kernel, cokernel, state)
	    node_t *kernel;
	    node_t *cokernel;
	    char *state;


	func is called once for each (kernel, cokernel) pair of the function.
	Note that in this context, the cokernel is then always just
	a single cube.

	The return value from func indicates whether to continue generating
	kernels.  If the return value is nonzero, kernel generation is 
	continued; if the return value is zero, the kernel generation is 
	stopped.




ex_subkernel_gen(node, func, level, state)
node_t *node;
int (*func)();
int level;
char *state;

	Calls the users function `func' once for each prime kernel
	intersection (i.e., each subkernel) of the function `node'.
	Subkernels are generated by first generating all kernels,
	forming the kernel-cube matrix, and then generating all prime
	rectangles of the kernel-cube matrix.  `level' controls the
	level of kernels generated when creating the kernel-cube
	matrix; currently, the only allowed values are 0 (for level 0
	kernels), or 1 (for all kernels).  `state' is passed along to
	contain user-defined state information during generation.  The
	function func is declared as:

	    int
	    func(kernel, cokernel, state)
	    node_t *kernel;
	    node_t *cokernel;
	    char *state;

	func is called once for each (kernel, cokernel) pair of the function.
	Note that in this context, the cokernel may consist of many cubes.

	The return value from func indicates whether to continue generating
	kernels.  If the return value is nonzero, subkernel generation is 
	continued; if the reeturn value is zero, the kernel generation is 
	stopped.



node_t *
ex_find_divisor(node, level, method)
node_t *node;
int level;
int method;

	Find a good divisor of the function `node'.  This is done by
	generating kernels, forming the kernel-cube matrix, and then
	finding a good-cost prime rectangle of this matrix.

	Level controls the level of kernels which are considered:

		level = 0: only level-0 kernels of node are used
		level = 1: all kernels of node are used

	Method controls selection of prime rectangles from the kernel-cube
	matrix:

		method = 0: ping_pong (fastest)
		method = 1: best-valued prime rectangle (SOP metric)

	If `node' has no divisors other than itself (i.e., if it is a
	level-0 kernel) then NIL(node_t) is returned instead.



node_t *
ex_find_divisor_quick(node)
node_t *node;

	Find a divisor of the function `node' quickly.  This is done by
	generating and returning the first kernel of the function `node'.
	If `node' has no divisors other than itself (i.e., if it is a
	level-0 kernel) then NIL(node_t) is returned instead.


int fast_extract(B, ddivisor_set)
sm_matrix *B;
ddset_t *ddivisor_set;

	Greeedy concurrent algorithm for finding best double cube divisor or
	single cube divisor. Finds all the double cube and single cube divisors
	of the nodes in the network. Associates a cost function to each node.
	Extract the node with the best cost function greedily.

