/*
 * Revision Control Information
 *
 * $Source: /users/pchong/CVS/sis/sis/clock/clock.doc,v $
 * $Author: pchong $
 * $Revision: 1.1.1.1 $
 * $Date: 2004/02/07 10:14:18 $
 *
 */
The clock package is the interface between the data structures
implementing the clocks and the routines that manipulate or use
information about the clocks. The clock definition is an
integral part of the network. 
    There are two sets of clocking data --- The user's 
specification and the current working values that are determined
by the program. The choice between the two sets is made by setting
a flag using the routine clock_set_current_setting().
    The clocks are represented by the nominal values for the
rising and falling edges. The specification in the blif file will
also denote dependencies between the different phase. The nominal 
values are expressed as fractions of the clock cycle. The skew in
the values is represented as absolute deviations. The value of the
clock cycle is either user-specified or automatically generated.

typedef struct clock_edge_struct {
    sis_clock_t *clock;
    int transition;	/* one of RISE_TRANSITION or FALL_TRANSITION */
} clock_edge_t;

    Here is brief description of the exported routines.
-------------------------------------------------------------------

sis_clock_t *
clock_create(name)
char *name;
    Create the clock signal entry. It saves the string passed to it.

void
clock_free(clock)
sis_clock_t *clock;
    Free the storage associated with the entry for the clock

int
clock_add_to_network(network, clock)
network_t *network;
sis_clock_t *clock;
    Adds the clock to the network structure
    Returns 1 if this is a new clock signal, 0 if a clock with the
    same name is already present. Does not overwrite the existing
    definition.

int
clock_delete_from_network(network, clock)
network_t *network;
sis_clock_t *clock;
    Deletes the clock from the network structure. Frees the memory
    associated with the clock structure. Returns 1 if success -- 0
    if clock is not part of the network (the error message can be
    obtained from error_string())

int
clock_add_dependency(edge1, edge2)
clock_edge_t edge1, edge2;
    Creates dependencies between two events --- edge1 and edge2.
    This routine will check if the edge "edge1" has the same nominal
    time as that of edge "edge2".  If they do then the two edges are 
    considered as a single event and changing the nominal value of one
    will cause a change in the other too. If the nominal times do not
    agree or the clocks are not part of the same network, returns 0.

void
clock_remove_dependency(edge1, edge2)
clock_edge_t edge1, edge2;
    Removes dependencies between two events --- edge1 and edge2. After
    this routine has been called the two events edge1 and edge2 are no
    longer coupled and can be manipulated independently (e.g. by calling
    clock_set_parameter() to modify one event without affecting the other).

lsGen
clock_gen_dependency(clock_edge)
clock_edge_t *clock_edge;
    Produces a generator to access all the dependent clock edges when
    one edge is given. The elements generated by looping over the 
    generator are of type "clock_edge_t". Do not free any of the generated
    clock_edge_t structures.

    As an example of the use of the generator to generate all the clock
    events that depend on the rising edge of clock_signal CLK_0

    lsGen gen;
    char *dummy;
    clock_edge_t edge, *new_edge;

    edge.clock = CLK_0;	/* CLK_0 is of type (sis_clock_t *) */
    /* can be one of RISE_TRANSITION or FALL_TRANSITION */
    edge.transition = RISE_TRANSITION;
    gen = clock_gen_dependency(edge);
    while (lsNext(gen, &dummy, LS_NH) == LS_OK){
	new_edge = (clock_edge_t *)dummy;
	/*
	 * do something with new_edge (DO NOT FREE)
	 */
    }
    (void)lsFinish(gen);

sis_clock_t *
clock_get_by_name(network, clk_name)
network_t *network;
char *clk_name;
    Given the name of a clock signal, returns the corresponding
    clock structure.  Returns NIL(sis_clock_t) if none is found

foreach_clock(network, gen, clock)
network_t *network;
lsGen gen;
sis_clock_t *clock;
    This is a macro expansion to allow the user to generate all the
    clocks in the network. The use is similar to the macros foreach_node
    etc. provided with the network package.

char *
clock_name(clock)
sis_clock_t *clock;
    Returns the name of a clock. Do not free the returned string.

typedef enum clock_setting_enum clock_setting_t 
enum clock_setting_enum {
    SPECIFICATION, WORKING
    };

void
clock_set_current_setting(network, mode)
network_t *network;
clock_setting_t mode;
    Sets the flag in the data structure specifying the clock data
    that will be retreived or set. "mode" is an enumerated type
    that can either be SPECIFICATION or WORKING

clock_setting_t
clock_get_current_setting(network)
    Returns the current value of the clock data flag.

int
network_num_clock(network)
network_t *network;
    Returns the number of clocks in the network.


void
clock_set_cycletime(network, value)
network_t *network;
double value;
	Sets the value of the cycle time. One can set either the 
	SPECIFICATION or WORKING value --- depends on the setting
	of a flag (clock_set_current_setting()).

double
clock_get_cycletime(network)
network_t *network;
	Returns the setting of the cycle_time. The value returned is 
	either the SPECIFICATION or WORKING --- depends on the setting
	of a flag (clock_set_current_setting()). If the returned value
	is negative then the cycle time has not been set.


typedef enum clock_param_enum clock_param_t;
enum clock_param_enum{
    CLOCK_NOMINAL_POSITION, CLOCK_ABSOLUTE_VALUE,
    CLOCK_LOWER_RANGE, CLOCK_UPPER_RANGE
    };

int
clock_num_dependent_edges(clock_edge)
clock_edge_t clock_edge;
    Returns the number of edges that depend on the specified "clock_edge".
    The set of dependent edges means that changing the nominal value for
    one edge will cause it to change for all the dependent edges.


int
clock_set_parameter(clock_edge, parameter, value)
clock_edge_t clock_edge;
clock_param_t parameter;
double value;
    The user can set parameters for the edges on a clock. The user
    can only set the parameters for the current setting of the clock
    flag (SPECIFICATION or WORKING).  Thus the user must be aware of
    the current setting before calling this routine. This poses the 
    constraint that the clock (part of clock_edge) be already in the
    network. 
    The routine returns 1 if successful, 0 if error (error occurs 
    when the clock is not part of a network). The clock_edge_t 
    structure specifies the clock and the edge (RISE_TRANSITION or
    FALL_TRANSITION) for which data is being set.

	The parameters that can be set are ---

    CLOCK_NOMINAL_POSITION specifies the relation of the edge in the
    clock cycle.  The clock cycle can be arbitrarily broken and edges
    specified as a percentage of the clock cycle. (Thus an edge midway
    in the clock cycle has a nominal position of 50.0).
    NOTE: when setting this parameter all dependent edges get modified too.

    CLOCK_LOWER_RANGE allows the user to set the amount by which the
    edge can preceed the nominal value. This is set only for the edge
    specified (i.e. the dependent edge values are not modified).

    CLOCK_UPPER_RANGE allows the user to specify the amount by which
    an edge can succeed the nominal value. This is set only for the
    edge specified.

double
clock_get_parameter(clock_edge, parameter)
clock_edge_t clock_edge;
clock_param_t parameter;
    Returns the value of the particular clocking parameter. The 
    parameter value returned depends on the setting of the clock
    flag (SPECIFICATION, WORKING). The clock_edge structure specifies
    the clock and the edge (RISE_TRANSITION or FALL_TRANSITION) being 
    queried.

	In addition to the parameters that can be set by the user,
    one can also query the following parameters ---

    CLOCK_ABSOLUTE returns the absolute time of the occurence of the
    clock edge.  This is done by finding the clock_cycle duration 
    from the network and translating the percentage specification of
    the nominal time into an absolute value. If the return value is 
    negative, there is an error (possibly the clock cycle duration 
    has not been set).

The clock package also provides a means of identifying the delay on the
control input of latches. Currently only one routine is provided. In
future this set of routines will be extented to provide more detailed
information as the users desire.

sis_clock_t *
clock_get_transitive_clock(network, node, model, phasep, offset)
network_t *network;
node_t *node;
delay_model_t model;
input_phase_t *phasep;
delay_time_t *offset;
    Given a node in the network, find the relevant clock signal that it
    is generated from. This is useful when the control input of a latch is
    known and delay data regarding it is needed. "offset" return the delay
    from the clock to the actual control node and "phasep" returns the 
    phase relationship of the node and the respective clock input. The
    delay is computed according to the delay model "model". Returns
    NIL(sis_clock_t) if a clock signal is not found in the transitive fanin.
