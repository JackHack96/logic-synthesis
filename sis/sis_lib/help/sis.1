.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.TH SIS 1CAD "1 July 1994"
.SH NAME
sis \- Sequential Interactive System
.SH SYNOPSIS
.B sis
[options] [file]
.SH DESCRIPTION
\fBSIS\fR is an algorithmic sequential circuit optimization
program.  \fBSIS\fR starts from a description
of a sequential logic macro-cell and produces
an optimized set of logic equations plus latches which preserves
the input-output behavior of the macro-cell.
The sequential circuit can be stored as a finite
state machine or as an implementation consisting of logic
gates and memory elements.
The program
includes algorithms for minimizing the area required to
implement the logic equations, algorithms for minimizing delay,
and a technology
mapping step to map a network into a user-specified cell library.
It includes all of the optimization techniques available in
\fBMIS\fR, and replaces \fBMIS\fR completely.
.PP
\fBSIS\fR can be run in interactive mode accepting commands
from the user, or in batch mode reading commands
from a file or from the command line.
If no options are given on the command line, \fBSIS\fP will
enter interactive mode.
Otherwise, \fBSIS\fP will enter batch mode.
When running in batch mode, \fBSIS\fP reads its
input from the file given on the command line, or from standard input
if no filename is given;
output is directed to standard output, unless \fB-o\fP is used to
specify an output filename.
.PP
When \fBSIS\fP starts-up, it performs an initial source of the
files $SIS/sis_lib/.misrc and $SIS/sis_lib/.sisrc.
Typically this defines a standard
set of aliases for various commands.
Following that the files ~/.misrc, ~/.sisrc, ./misrc, and ./sisrc
are sourced for user-defined aliases at startup.
.SH OPTIONS
.TP 8
.B -c cmdline
Run \fBSIS\fR in batch mode, and execute \fBcmdline\fR.
Multiple commands are separated with semicolons.
.TP 8
.B -f script
Run \fBSIS\fR in the batch mode, and execute commands from the
file \fBscript\fR.
.TP 8
.B -t type
Specifies the type of the input when running in batch mode.
The legal input types are:
Berkeley Logic Interchange Format (\fB-t blif\fP),
eqntott(1CAD)-format equation input (\fB-t eqn\fP),
\fIKISS2 format\fR (\fB-t kiss\fP),
\fIOct Logic View\fR (\fB-t oct\fP),
Berkeley PLA Format (\fB-t pla\fP),
\fISLIF format\fR (\fB-t slif\fP),
and suppress input (\fB-t none\fP).
The default input type is \fIblif\fR.
.TP 8
.B -T type
Specifies the type of the output when running in batch mode.
The legal output types are:
bdnet(1CAD)-format net-list (\fB-T bdnet\fP),
Berkeley Logic Interchange Format (\fB-T blif\fP),
eqntott(1CAD)-format equation input (\fB-T eqn\fP),
\fIKISS2 format\fR (\fB-T kiss\fP),
\fIOct logic view\fR (\fB-T oct\fP),
Berkeley PLA Format (\fB-T pla\fP),
\fISLIF format\fR (\fB-T slif\fP),
and suppress output (\fB-T none\fP).
The default output type is \fIblif\fR.
.TP 8
.B -o file
Specifies the output file when running in batch mode.
For \fIOct\fP output, this is a string of the
form \fIcell\fP:\fIview\fP.
The default for the output is the standard output.
.TP 8
.B -s
Suppress sourcing the commands from the standard
startup script ($SIS/sis_lib/.misrc and $SIS/sis_lib/.sisrc).
.TP 8
.B -x
For batch mode operation, suppress reading an initial network, and
suppress writing an output network.
Equivalent to \fB-t none -T none\fP.
.de XX
.sp 1
.LP
.ti -5
.B
..
.de X1
.br
.ti -5
.B
..
.PP
.SH COMMAND SUMMARY
All commands are summarized below according
to their function : network manipulation (operations
on the logic-level implementation),
ASTG manipulation (operations on the asynchronous
signal transition graph), STG manipulation (operations
on the synchronous state transition graph),
input-output, network status, command interpreter,
and miscellaneous.
The last two tables summarize the newest commands that
operate on ASTG's and sequential circuits, respectively.
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wact_map
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wadd_inverter
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_slow
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_syn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_to_f
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_to_stg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wbuffer_opt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wchng_clock
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wcollapse
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wdecomp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \weliminate
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wenv_seq_dc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wequiv_nets
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wespresso
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wextract_seq_dc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfactor
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfanout_alg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfanout_param
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfree_dc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wforce_init_0
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfull_simplify
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfx
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wgcx
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wgkx
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \winvert
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wlatch_output
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wmap
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wone_hot
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wphase
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wred_removal
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wreduce_depth
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wremove_dep
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wremove_latches
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wreplace
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wresub
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wretime
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsimplify
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wspeed_up
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wspeed_up_alg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstate_assign
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_extract
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_to_network
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsweep
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wtech_decomp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwd
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wtechnology mapping to Actel architecture
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wadd inverters to the network to make all gates negative
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremove hazards from the ASTG implementation
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \w(uses bounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsynthesize a two-level implementation from the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \w(uses unbounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate a two-level implementation of each output of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \w(uses bounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate an STG from the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \winserts buffering trees for high fanout gates
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtoggles clock setting between user-specification and generated values
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcollapse a network or a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecompose a node into a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \weliminates nodes whose value falls below a threshold
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract sequential don't cares based on the environment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgroup and merge nets by equivalence classes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcollapse network and minimize with a two-level minimizer
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract sequential don't cares
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdetermine a factored form for a node
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wselect a fanout optimization algorithm (to be used by map)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset some parameters for fanout algorithm (to be used by map)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfrees the external don't care network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmodify so all latches to have a 0 initial state
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimplify the nodes using local compatible don't cares
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdo fast extraction of the best double cube and single cube divisors
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract common cubes from the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract common multiple-cube divisors from the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \winvert a node, and toggle the phase of all of its fanouts
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wforces some outputs to be fed directly by latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtechnology mapping to find an implementation for the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wquick one-hot encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wphase assignment to minimize number of inverters
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wperform redundancy removal via atpg
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wincrease the speed before mapping by reducing the depth
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremoves some structural (but not logical) dependencies
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremoves redundant latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wquick algebraic decomposition on 2-input NANDs
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wperform resubstitution of a node into other nodes in the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmove the latches in the circuit to minimize cycle time/# latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtwo-level minimization of each node
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wrestructure critical paths to reduce delay
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wseveral algorithms for performance enhancement
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcreate the logic from the STG using state assignment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract an STG from the logic
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wconverts a state-encoded STG to a logic network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremove all inverters, buffers, and unnecessary latches from the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecompose a network for technology mapping
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wre-express a node using another node using weak division
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBNetwork Manipulation Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 178 file Input is too wide - \n(TW units
.ne 49v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBNetwork Manipulation Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'act_map\h'|\n(41u'technology mapping to Actel architecture
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'add_inverter\h'|\n(41u'add inverters to the network to make all gates negative
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_slow\h'|\n(41u'remove hazards from the ASTG implementation
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'(uses bounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_syn\h'|\n(41u'synthesize a two-level implementation from the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'(uses unbounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_to_f\h'|\n(41u'generate a two-level implementation of each output of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'(uses bounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_to_stg\h'|\n(41u'generate an STG from the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'buffer_opt\h'|\n(41u'inserts buffering trees for high fanout gates
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'chng_clock\h'|\n(41u'toggles clock setting between user-specification and generated values
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'collapse\h'|\n(41u'collapse a network or a set of nodes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'decomp\h'|\n(41u'decompose a node into a set of nodes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'eliminate\h'|\n(41u'eliminates nodes whose value falls below a threshold
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'env_seq_dc\h'|\n(41u'extract sequential don't cares based on the environment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'equiv_nets\h'|\n(41u'group and merge nets by equivalence classes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'espresso\h'|\n(41u'collapse network and minimize with a two-level minimizer
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'extract_seq_dc\h'|\n(41u'extract sequential don't cares
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'factor\h'|\n(41u'determine a factored form for a node
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'fanout_alg\h'|\n(41u'select a fanout optimization algorithm (to be used by map)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'fanout_param\h'|\n(41u'set some parameters for fanout algorithm (to be used by map)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'free_dc\h'|\n(41u'frees the external don't care network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'force_init_0\h'|\n(41u'modify so all latches to have a 0 initial state
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'full_simplify\h'|\n(41u'simplify the nodes using local compatible don't cares
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'fx\h'|\n(41u'do fast extraction of the best double cube and single cube divisors
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'gcx\h'|\n(41u'extract common cubes from the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'gkx\h'|\n(41u'extract common multiple-cube divisors from the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'invert\h'|\n(41u'invert a node, and toggle the phase of all of its fanouts
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'latch_output\h'|\n(41u'forces some outputs to be fed directly by latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'map\h'|\n(41u'technology mapping to find an implementation for the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'one_hot\h'|\n(41u'quick one-hot encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'phase\h'|\n(41u'phase assignment to minimize number of inverters
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'red_removal\h'|\n(41u'perform redundancy removal via atpg
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'reduce_depth\h'|\n(41u'increase the speed before mapping by reducing the depth
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'remove_dep\h'|\n(41u'removes some structural (but not logical) dependencies
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'remove_latches\h'|\n(41u'removes redundant latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'replace\h'|\n(41u'quick algebraic decomposition on 2-input NANDs
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'resub\h'|\n(41u'perform resubstitution of a node into other nodes in the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'retime\h'|\n(41u'move the latches in the circuit to minimize cycle time/# latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'simplify\h'|\n(41u'two-level minimization of each node
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'speed_up\h'|\n(41u'restructure critical paths to reduce delay
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'speed_up_alg\h'|\n(41u'several algorithms for performance enhancement
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'state_assign\h'|\n(41u'create the logic from the STG using state assignment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_extract\h'|\n(41u'extract an STG from the logic
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_to_network\h'|\n(41u'converts a state-encoded STG to a logic network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sweep\h'|\n(41u'remove all inverters, buffers, and unnecessary latches from the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'tech_decomp\h'|\n(41u'decompose a network for technology mapping
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wd\h'|\n(41u're-express a node using another node using weak division
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-54
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wxl_absorb
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_ao
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_coll_ck
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_cover
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_decomp_two
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_imp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_k_decomp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_merge
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_part_coll
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_partition
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_rl
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxl_split
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wdecreases number of fanins to make nodes feasible
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wAND-OR decomposition of an infeasible network to a feasible one
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcollapse and apply Roth-Karp decomposition and cofactoring
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wglobal cover of nodes by "xilinx" blocks of pld gates
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecomposition into two compatible "xilinx" functions
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerates a feasible network using various decomposition schemes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wKarp-Roth decomposition for mapping into "xilinx" gates
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmerge "xilinx" blocks
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wpartial collapse
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wlocal cover of nodes by "xilinx" blocks of pld gates
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtiming optimization for table look up architectures
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecompose a network (using routing complexity as cost)
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBNetwork Manipulation Commands (cont.)\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 198 file Input is too wide - \n(TW units
.ne 13v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBNetwork Manipulation Commands (cont.)\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_absorb\h'|\n(41u'decreases number of fanins to make nodes feasible
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_ao\h'|\n(41u'AND-OR decomposition of an infeasible network to a feasible one
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_coll_ck\h'|\n(41u'collapse and apply Roth-Karp decomposition and cofactoring
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_cover\h'|\n(41u'global cover of nodes by "xilinx" blocks of pld gates
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_decomp_two\h'|\n(41u'decomposition into two compatible "xilinx" functions
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_imp\h'|\n(41u'generates a feasible network using various decomposition schemes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_k_decomp\h'|\n(41u'Karp-Roth decomposition for mapping into "xilinx" gates
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_merge\h'|\n(41u'merge "xilinx" blocks
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_part_coll\h'|\n(41u'partial collapse
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_partition\h'|\n(41u'local cover of nodes by "xilinx" blocks of pld gates
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_rl\h'|\n(41u'timing optimization for table look up architectures
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xl_split\h'|\n(41u'decompose a network (using routing complexity as cost)
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-18
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wastg_add_state
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_contract
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_encode
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_lockgraph
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_marking
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_persist
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_state_min
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_stg_scr
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_to_astg
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wadds states to the ASTG to guarantee implementability
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate the contracted net for a signal of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcritical race-free STG encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wbuild the lock graph for the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset or display the initial marking of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmake the ASTG persistent
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wminimizes the current STG and derives encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \winformation for the associated ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtransforms the STG to one that satisfies SCR property
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtransforms the STG (with the SCR property) to an ASTG
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBASTG Manipulation Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 216 file Input is too wide - \n(TW units
.ne 11v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBASTG Manipulation Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_add_state\h'|\n(41u'adds states to the ASTG to guarantee implementability
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_contract\h'|\n(41u'generate the contracted net for a signal of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_encode\h'|\n(41u'critical race-free STG encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_lockgraph\h'|\n(41u'build the lock graph for the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_marking\h'|\n(41u'set or display the initial marking of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_persist\h'|\n(41u'make the ASTG persistent
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_state_min\h'|\n(41u'minimizes the current STG and derives encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'information for the associated ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_stg_scr\h'|\n(41u'transforms the STG to one that satisfies SCR property
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_to_astg\h'|\n(41u'transforms the STG (with the SCR property) to an ASTG
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-16
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wstate_assign
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstate_minimize
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_to_astg
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wassign binary codes to the states in the STG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wminimize the number of states in the STG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtransforms the STG (with the SCR property) to an ASTG
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBSTG Manipulation Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 227 file Input is too wide - \n(TW units
.ne 4v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBSTG Manipulation Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'state_assign\h'|\n(41u'assign binary codes to the states in the STG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'state_minimize\h'|\n(41u'minimize the number of states in the STG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_to_astg\h'|\n(41u'transforms the STG (with the SCR property) to an ASTG
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-9
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wc_check
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wc_opt
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wverifies satisfaction of clocking constraints
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcomputes the optimal clock for a given clocking scheme
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBTiming Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 237 file Input is too wide - \n(TW units
.ne 3v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBTiming Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'c_check\h'|\n(41u'verifies satisfaction of clocking constraints
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'c_opt\h'|\n(41u'computes the optimal clock for a given clocking scheme
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-8
.sp 2
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wread_astg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_blif
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_eqn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_kiss
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_library
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_oct
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_pla
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_slif
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wset_delay
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wset_state
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_astg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_bdnet
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_blif
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_eqn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_kiss
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_oct
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_pla
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_pds
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_slif
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wread a signal transition graph in ASTG format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network in BLIF format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network in eqntott(1CAD) format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread an STG in KISS2 format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a library description file
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network from an Oct Logic view
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network in PLA format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network in Stanford Logic Interchange Format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset delay parameters for primary inputs and outputs 
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset the current state in a sequential circuit to the given state
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current signal transition graph in ASTG format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current (mapped) network in bdnet(1CAD) format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in BLIF format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in eqntott(1CAD) equation format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the STG in KISS2 format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network into an Oct Logic view
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in PLA(5CAD) format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in PDS format for Xilinx
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in SLIF format
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBInput-Output Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 264 file Input is too wide - \n(TW units
.ne 20v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBInput-Output Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_astg\h'|\n(41u'read a signal transition graph in ASTG format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_blif\h'|\n(41u'read a network in BLIF format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_eqn\h'|\n(41u'read a network in eqntott(1CAD) format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_kiss\h'|\n(41u'read an STG in KISS2 format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_library\h'|\n(41u'read a library description file
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_oct\h'|\n(41u'read a network from an Oct Logic view
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_pla\h'|\n(41u'read a network in PLA format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_slif\h'|\n(41u'read a network in Stanford Logic Interchange Format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'set_delay\h'|\n(41u'set delay parameters for primary inputs and outputs 
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'set_state\h'|\n(41u'set the current state in a sequential circuit to the given state
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_astg\h'|\n(41u'write the current signal transition graph in ASTG format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_bdnet\h'|\n(41u'write the current (mapped) network in bdnet(1CAD) format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_blif\h'|\n(41u'write the current network in BLIF format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_eqn\h'|\n(41u'write the current network in eqntott(1CAD) equation format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_kiss\h'|\n(41u'write the STG in KISS2 format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_oct\h'|\n(41u'write the current network into an Oct Logic view
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_pla\h'|\n(41u'write the current network in PLA(5CAD) format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_pds\h'|\n(41u'write the current network in PDS format for Xilinx
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_slif\h'|\n(41u'write the current network in SLIF format
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-25
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wastg_current
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_print_sg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_print_stat
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wconstraints
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wplot_blif
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_estimate
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_free_info
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_print
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_altname
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_clock
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_delay
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_factor
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_gate
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_io
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_kernel
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_latch
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_level
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_library
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_map_stats
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_state
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_stats
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_value
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wdisplay information about the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the state graph of the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the statistics of the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the delay constraints for a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wplot the network in a graphics window (only available in \fBxsis\fR)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \westimate dissipated power based on switching activity
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfrees memory associated with power calculations
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint switcing probabilities and capacitances
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint logic function associated with a node
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the short (and long) names for a node
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint out information about the clocks in the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtiming simulate a network and print results
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the factored form associated with a node
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint information about the gates used in the mapped network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the fanin and fanout of a node (or the network)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the kernels (and subkernels) of a set of functions
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint out information about all the latches in the circuit
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the levels of a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wlist the gates in the current library
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint delay and area information for a mapped network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the current state of a sequential circuit
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint statistics on a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the value of a set of nodes
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBNetwork Status Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 295 file Input is too wide - \n(TW units
.ne 24v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBNetwork Status Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_current\h'|\n(41u'display information about the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_print_sg\h'|\n(41u'print the state graph of the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_print_stat\h'|\n(41u'print the statistics of the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'constraints\h'|\n(41u'print the delay constraints for a set of nodes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'plot_blif\h'|\n(41u'plot the network in a graphics window (only available in \fBxsis\fR)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_estimate\h'|\n(41u'estimate dissipated power based on switching activity
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_free_info\h'|\n(41u'frees memory associated with power calculations
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_print\h'|\n(41u'print switcing probabilities and capacitances
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print\h'|\n(41u'print logic function associated with a node
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_altname\h'|\n(41u'print the short (and long) names for a node
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_clock\h'|\n(41u'print out information about the clocks in the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_delay\h'|\n(41u'timing simulate a network and print results
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_factor\h'|\n(41u'print the factored form associated with a node
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_gate\h'|\n(41u'print information about the gates used in the mapped network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_io\h'|\n(41u'print the fanin and fanout of a node (or the network)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_kernel\h'|\n(41u'print the kernels (and subkernels) of a set of functions
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_latch\h'|\n(41u'print out information about all the latches in the circuit
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_level\h'|\n(41u'print the levels of a set of nodes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_library\h'|\n(41u'list the gates in the current library
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_map_stats\h'|\n(41u'print delay and area information for a mapped network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_state\h'|\n(41u'print the current state of a sequential circuit
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_stats\h'|\n(41u'print statistics on a set of nodes
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_value\h'|\n(41u'print the value of a set of nodes
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-29
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \walias
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wchng_name
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wecho
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \whelp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \whistory
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wquit
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wreset_name
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsave
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wset
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsource
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wtime
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wtimeout
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wunalias
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wundo
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wunset
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wusage
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wprovide an alias for a command
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wswitch between short and long forms for node names
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmerely echo the arguments
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprovide on-line information on commands
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wa UNIX-like history mechanism inside the \fBSIS\fP shell
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wexit \fBSIS\fP
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wrename all of the short names in the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsave a copy of the current executable
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset an environment variable
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wexecute commands from a file
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprovide a simple elapsed time value
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsends an interrupt to the \fBSIS\fR process
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremove the definition of an alias
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wundo the result of the last command which changed the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wunset an environment variable
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprovide a dump of process statistics
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBCommand Interpreter\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 319 file Input is too wide - \n(TW units
.ne 17v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBCommand Interpreter\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'alias\h'|\n(41u'provide an alias for a command
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'chng_name\h'|\n(41u'switch between short and long forms for node names
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'echo\h'|\n(41u'merely echo the arguments
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'help\h'|\n(41u'provide on-line information on commands
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'history\h'|\n(41u'a UNIX-like history mechanism inside the \fBSIS\fP shell
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'quit\h'|\n(41u'exit \fBSIS\fP
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'reset_name\h'|\n(41u'rename all of the short names in the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'save\h'|\n(41u'save a copy of the current executable
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'set\h'|\n(41u'set an environment variable
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'source\h'|\n(41u'execute commands from a file
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'time\h'|\n(41u'provide a simple elapsed time value
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'timeout\h'|\n(41u'sends an interrupt to the \fBSIS\fR process
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'unalias\h'|\n(41u'remove the definition of an alias
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'undo\h'|\n(41u'undo the result of the last command which changed the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'unset\h'|\n(41u'unset an environment variable
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'usage\h'|\n(41u'provide a dump of process statistics
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-22
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \watpg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wbdsyn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wenv_verify_fsm
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wshort_tests
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim_verify
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsimulate
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_cover
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wverify
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wverify_fsm
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wperform combinational atpg using SAT approach
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wspecial command used by bdsyn(1CAD)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify equivalence of two networks in an environment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate small sequential test sets
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify networks equivalent via simulation
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wlogic simulation of the current network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcheck that the STG behavior covers the logic implementation
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify equivalence of two combinational networks
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify equivalence of two combinational or sequential networks
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBMiscellaneous\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 336 file Input is too wide - \n(TW units
.ne 10v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBMiscellaneous\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'atpg\h'|\n(41u'perform combinational atpg using SAT approach
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'bdsyn\h'|\n(41u'special command used by bdsyn(1CAD)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'env_verify_fsm\h'|\n(41u'verify equivalence of two networks in an environment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'short_tests\h'|\n(41u'generate small sequential test sets
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim_verify\h'|\n(41u'verify networks equivalent via simulation
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'simulate\h'|\n(41u'logic simulation of the current network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_cover\h'|\n(41u'check that the STG behavior covers the logic implementation
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'verify\h'|\n(41u'verify equivalence of two combinational networks
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'verify_fsm\h'|\n(41u'verify equivalence of two combinational or sequential networks
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-15
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wastg_add_state
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_contract
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_current
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_encode
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_lockgraph
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_marking
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_persist
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_print_sg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_print_stat
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_slow
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_state_min
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_stg_scr
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_syn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_to_f
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wastg_to_stg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_astg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_astg
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wadds states to the ASTG to guarantee implementability
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate the contracted net for a signal of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdisplay information about the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcritical race-free STG encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wbuild the lock graph for the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset or display the initial marking of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmake the ASTG persistent
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the state graph of the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint the statistics of the current ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremove hazards from the ASTG (uses bounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wminimizes the current STG and derives encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \winformation for the associated ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtransforms the STG to one that satisfies SCR property
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsynthesize a two-level implementation from the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \w(uses unbounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate a two-level implementation of each output of the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \w(uses bounded wire delay model)
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate an STG from the ASTG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a signal transition graph in ASTG format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current signal transition graph in ASTG format
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBAsynchronous Synthesis Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 364 file Input is too wide - \n(TW units
.ne 21v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBAsynchronous Synthesis Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_add_state\h'|\n(41u'adds states to the ASTG to guarantee implementability
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_contract\h'|\n(41u'generate the contracted net for a signal of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_current\h'|\n(41u'display information about the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_encode\h'|\n(41u'critical race-free STG encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_lockgraph\h'|\n(41u'build the lock graph for the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_marking\h'|\n(41u'set or display the initial marking of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_persist\h'|\n(41u'make the ASTG persistent
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_print_sg\h'|\n(41u'print the state graph of the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_print_stat\h'|\n(41u'print the statistics of the current ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_slow\h'|\n(41u'remove hazards from the ASTG (uses bounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_state_min\h'|\n(41u'minimizes the current STG and derives encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'information for the associated ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_stg_scr\h'|\n(41u'transforms the STG to one that satisfies SCR property
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_syn\h'|\n(41u'synthesize a two-level implementation from the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'(uses unbounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_to_f\h'|\n(41u'generate a two-level implementation of each output of the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'(uses bounded wire delay model)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'astg_to_stg\h'|\n(41u'generate an STG from the ASTG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_astg\h'|\n(41u'read a signal transition graph in ASTG format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_astg\h'|\n(41u'write the current signal transition graph in ASTG format
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-26
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \wc_check
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wc_opt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wchng_clock
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wenv_seq_dc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wenv_verify_fsm
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wextract_seq_dc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wforce_init_0
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wlatch_output
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wone_hot
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_estimate
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_free_info
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpower_print
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_clock
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprint_latch
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_kiss
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wread_slif
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wremove_latches
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wretime
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wset_delay
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wset_state
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wshort_tests
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstate_assign
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstate_minimize
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_cover
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_extract
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wstg_to_network
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wverify_fsm
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_kiss
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwrite_slif
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wverifies satisfaction of clocking constraints
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcomputes the optimal clock for a given clocking scheme
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtoggles clock setting between user-specification and generated values
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract sequential don't cares based on the environment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify equivalence of two networks in an environment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract sequential don't cares
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmodify so all latches to have a 0 initial state
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wforces some outputs to be fed directly by latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wquick one-hot encoding
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \westimate dissipated power based on switching activity
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfrees memory associated with power calculations
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint switcing probabilities and capacitances
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint out information about the clocks in the network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint out information about all the latches in the circuit
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread an STG in KISS2 format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread a network in Stanford Logic Interchange Format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wremoves redundant latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wmove the latches in the circuit to minimize cycle time/# latches
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset delay parameters for primary inputs and outputs 
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wset the current state in a sequential circuit to the given state
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wgenerate small sequential test sets
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcreate the logic from the STG using state assignment
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wminimize the number of states in the STG
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcheck that the STG behavior covers the logic implementation
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract an STG from the logic
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wconverts a state-encoded STG to a logic network
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify equivalence of two combinational or sequential networks
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the STG in KISS2 format
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite the current network in SLIF format
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \w\fBSequential Synthesis Commands\fP-\n(80-3n-\n(81
.if \n(38>0 .nr 38 \n(38/1
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 401 file Input is too wide - \n(TW units
.ne 30v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBSequential Synthesis Commands\fP
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'c_check\h'|\n(41u'verifies satisfaction of clocking constraints
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'c_opt\h'|\n(41u'computes the optimal clock for a given clocking scheme
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'chng_clock\h'|\n(41u'toggles clock setting between user-specification and generated values
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'env_seq_dc\h'|\n(41u'extract sequential don't cares based on the environment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'env_verify_fsm\h'|\n(41u'verify equivalence of two networks in an environment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'extract_seq_dc\h'|\n(41u'extract sequential don't cares
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'force_init_0\h'|\n(41u'modify so all latches to have a 0 initial state
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'latch_output\h'|\n(41u'forces some outputs to be fed directly by latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'one_hot\h'|\n(41u'quick one-hot encoding
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_estimate\h'|\n(41u'estimate dissipated power based on switching activity
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_free_info\h'|\n(41u'frees memory associated with power calculations
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'power_print\h'|\n(41u'print switcing probabilities and capacitances
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_clock\h'|\n(41u'print out information about the clocks in the network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'print_latch\h'|\n(41u'print out information about all the latches in the circuit
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_kiss\h'|\n(41u'read an STG in KISS2 format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'read_slif\h'|\n(41u'read a network in Stanford Logic Interchange Format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'remove_latches\h'|\n(41u'removes redundant latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'retime\h'|\n(41u'move the latches in the circuit to minimize cycle time/# latches
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'set_delay\h'|\n(41u'set delay parameters for primary inputs and outputs 
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'set_state\h'|\n(41u'set the current state in a sequential circuit to the given state
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'short_tests\h'|\n(41u'generate small sequential test sets
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'state_assign\h'|\n(41u'create the logic from the STG using state assignment
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'state_minimize\h'|\n(41u'minimize the number of states in the STG
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_cover\h'|\n(41u'check that the STG behavior covers the logic implementation
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_extract\h'|\n(41u'extract an STG from the logic
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'stg_to_network\h'|\n(41u'converts a state-encoded STG to a logic network
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'verify_fsm\h'|\n(41u'verify equivalence of two combinational or sequential networks
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_kiss\h'|\n(41u'write the STG in KISS2 format
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'write_slif\h'|\n(41u'write the current network in SLIF format
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-35
.sp .5i
.SH NODELIST ARGUMENTS
Most commands which take a node also take a list of nodes as an
argument.  This is referred to as a \fBnode-list\fP in the
documentation below.
This list of nodes includes \fB*\fP to specify
all nodes in the network, \fBi()\fP to specify the primary
inputs of the network, \fBo()\fP to specify the primary
outputs of the network, \fBi(node)\fP to specify the
direct fanin of \fInode\fP, and \fBo(node)\fP to specify the
direct fanout of \fInode\fP.
.sp .5i
.SH STANDARD ALIASES
When \fBSIS\fP starts, it executes commands from a system startup file
(usually $(SIS)/sis_lib/.misrc and $(SIS)/sis_lib/.sisrc).
This defines a standard set of
aliases, and then sources the files ~/.misrc, ~/.sisrc, ./misrc,
and ./sisrc to allow
users to define their own set of aliases.  The default alias set includes
the following aliases which have proven useful.  Note that many of the aliases
are intended for compatibility with \fBSIS\fP Version #1.0.
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81 82
.nr 80 0
.nr 38 \walias
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w1h
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wai
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \walt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wasb
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wclp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wcrit
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wel
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wexit
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wfs
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wgd
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wgf
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wgp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \winv
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \woh
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wman
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wnts
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpat
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpd
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpf
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpg
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpgc
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpio
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpk
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpl
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wplt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wplv
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wprt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wps
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpsf
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpst
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wpv
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wq
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wqd
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wqf
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wqp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wra
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrd
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wre
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrk
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrl
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrlib
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wro
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrr
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrs
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wcommand
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsa nova -e h
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wadd_inverter
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_altname
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wresub -a
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wchng_name
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcollapse
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wpd -a -p 2
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \weliminate
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wquit
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfull_simplify
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecomp -g
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfactor -g
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wphase -g
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \winvert
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wone_hot
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \whelp
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_stats
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_delay -a
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_clock
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_delay
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_factor
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_gate
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_gate -s
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_io
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_kernel
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_latch
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_delay -l
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_level
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wp -n
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_delay -r
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_stats -f
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_stats
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_delay -s
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wprint_value
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wquit
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wdecomp -q
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wfactor -g
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wphase -q
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_astg
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wreduce_depth
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_eqn
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_kiss
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_blif
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_library
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_oct
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_pla
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wred_removal
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wread_slif
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 82 0
.nr 38 \wdescription
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wdo 1-hot state encoding using nova
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wadd inverters to a network to correct the phases
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint both long and short names for a node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \walgebraic resubstitution
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wtoggle between long and short names
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wcollapse network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint out the 2 most critical paths
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \weliminate nodes below a threshold
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wterminate program
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wsimplify each node function
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wgood decomposition (i.e., best kernel decomposition)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wgood factoring (i.e., best kernel factoring)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wgood phase assignment (i.e., more expensive)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \winvert a node keeping network function consistent
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wdo quick one-hot encoding
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint out command information
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint network status (including factored form)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint sum-of-products form of a node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint node arrival times
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint information about clocks in the network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint delay
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint factored form of a node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint gate information for a node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wsummarize gate information for the network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint inputs and outputs of a node or the network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint kernels of a node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint latch information
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint output loading for each node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint the level of each node
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint nodes in 'negative' form
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint node required times
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint network status (including factored form)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint network status
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint node slack times
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wprint node values
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wterminate program
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wquick decomposition (i.e., any kernel decomposition)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wquick factoring (i.e., any kernel factoring)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wquick phase (i.e., simple greedy algorithm)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a signal transition graph in ASTG format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wincrease speed before mapping by reducing the depth
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread equations from a file
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread an STG in KISS2 format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a blif network from a file
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a library
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a network from an Oct view
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a PLA in espresso format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wremove combinationally redundant signals
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wread a network in SLIF fornat
.if \n(82<\n(38 .nr 82 \n(38
.82
.rm 82
.nr 38 \w\fBStandard Aliases\fP-\n(80-3n-\n(81-3n-\n(82
.if \n(38>0 .nr 38 \n(38/2
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 82 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr 42 \n(81+(3*\n(38)
.nr 82 +\n(42
.nr TW \n(82
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 480 file Input is too wide - \n(TW units
.ne 51v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBStandard Aliases\fP
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'alias\h'|\n(41u'command\h'|\n(42u'description
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'1h\h'|\n(41u'sa nova -e h\h'|\n(42u'do 1-hot state encoding using nova
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'ai\h'|\n(41u'add_inverter\h'|\n(42u'add inverters to a network to correct the phases
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'alt\h'|\n(41u'print_altname\h'|\n(42u'print both long and short names for a node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'asb\h'|\n(41u'resub -a\h'|\n(42u'algebraic resubstitution
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'c\h'|\n(41u'chng_name\h'|\n(42u'toggle between long and short names
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'clp\h'|\n(41u'collapse\h'|\n(42u'collapse network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'crit\h'|\n(41u'pd -a -p 2\h'|\n(42u'print out the 2 most critical paths
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'el\h'|\n(41u'eliminate\h'|\n(42u'eliminate nodes below a threshold
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'exit\h'|\n(41u'quit\h'|\n(42u'terminate program
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'fs\h'|\n(41u'full_simplify\h'|\n(42u'simplify each node function
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'gd\h'|\n(41u'decomp -g\h'|\n(42u'good decomposition (i.e., best kernel decomposition)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'gf\h'|\n(41u'factor -g\h'|\n(42u'good factoring (i.e., best kernel factoring)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'gp\h'|\n(41u'phase -g\h'|\n(42u'good phase assignment (i.e., more expensive)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'inv\h'|\n(41u'invert\h'|\n(42u'invert a node keeping network function consistent
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'oh\h'|\n(41u'one_hot\h'|\n(42u'do quick one-hot encoding
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'man\h'|\n(41u'help\h'|\n(42u'print out command information
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'nts\h'|\n(41u'print_stats\h'|\n(42u'print network status (including factored form)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'p\h'|\n(41u'print\h'|\n(42u'print sum-of-products form of a node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pat\h'|\n(41u'print_delay -a\h'|\n(42u'print node arrival times
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pc\h'|\n(41u'print_clock\h'|\n(42u'print information about clocks in the network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pd\h'|\n(41u'print_delay\h'|\n(42u'print delay
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pf\h'|\n(41u'print_factor\h'|\n(42u'print factored form of a node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pg\h'|\n(41u'print_gate\h'|\n(42u'print gate information for a node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pgc\h'|\n(41u'print_gate -s\h'|\n(42u'summarize gate information for the network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pio\h'|\n(41u'print_io\h'|\n(42u'print inputs and outputs of a node or the network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pk\h'|\n(41u'print_kernel\h'|\n(42u'print kernels of a node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pl\h'|\n(41u'print_latch\h'|\n(42u'print latch information
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'plt\h'|\n(41u'print_delay -l\h'|\n(42u'print output loading for each node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'plv\h'|\n(41u'print_level\h'|\n(42u'print the level of each node
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pn\h'|\n(41u'p -n\h'|\n(42u'print nodes in 'negative' form
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'prt\h'|\n(41u'print_delay -r\h'|\n(42u'print node required times
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'ps\h'|\n(41u'print_stats -f\h'|\n(42u'print network status (including factored form)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'psf\h'|\n(41u'print_stats\h'|\n(42u'print network status
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pst\h'|\n(41u'print_delay -s\h'|\n(42u'print node slack times
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'pv\h'|\n(41u'print_value\h'|\n(42u'print node values
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'q\h'|\n(41u'quit\h'|\n(42u'terminate program
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'qd\h'|\n(41u'decomp -q\h'|\n(42u'quick decomposition (i.e., any kernel decomposition)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'qf\h'|\n(41u'factor -g\h'|\n(42u'quick factoring (i.e., any kernel factoring)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'qp\h'|\n(41u'phase -q\h'|\n(42u'quick phase (i.e., simple greedy algorithm)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'ra\h'|\n(41u'read_astg\h'|\n(42u'read a signal transition graph in ASTG format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rd\h'|\n(41u'reduce_depth\h'|\n(42u'increase speed before mapping by reducing the depth
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u're\h'|\n(41u'read_eqn\h'|\n(42u'read equations from a file
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rk\h'|\n(41u'read_kiss\h'|\n(42u'read an STG in KISS2 format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rl\h'|\n(41u'read_blif\h'|\n(42u'read a blif network from a file
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rlib\h'|\n(41u'read_library\h'|\n(42u'read a library
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'ro\h'|\n(41u'read_oct\h'|\n(42u'read a network from an Oct view
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rp\h'|\n(41u'read_pla\h'|\n(42u'read a PLA in espresso format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rr\h'|\n(41u'red_removal\h'|\n(42u'remove combinationally redundant signals
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rs\h'|\n(41u'read_slif\h'|\n(42u'read a network in SLIF fornat
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-57
.sp 1
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81 82
.nr 80 0
.nr 38 \walias
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrsn
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wrt
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsa
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wse
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim0
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim1
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim2
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsim3
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsm
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wso 
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wsw
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wtd
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wu
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wv
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwa
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwb
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwe
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwk
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwl
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwp
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wwo
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wws
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wxdc
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wcommand
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wreset_name
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wretime -n
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wstate_assign
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wstg_extract
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimulate
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimplify -d
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimplify -m nocomp -d
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimplify
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsimplify -m nocomp
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wstate_minimize
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsource
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wspeed_up
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wsweep
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wtech_decomp
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wundo
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wverify_fsm
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_astg
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_bdnet
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_eqn
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_kiss
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_blif
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_pla
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_oct
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wwrite_slif
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wextract_seq_dc
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 82 0
.nr 38 \wdescription
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wreset all short names starting from 'a'
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wretime an unmapped network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wcreate the logic from the STG using state assignment
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wextract an STG from the logic
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wlogic simulation on a network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wquick minimization of a node (no don't cares)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wcomplete minimization of a node (no don't cares)
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wsingle pass minimization with fanin DC-set
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wcomplete minimization with fanin DC-set
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wminimize the number of states in the STG
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wsource a script file
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wcritical path restructuring to reduce delay
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wremove buffers, inverters from a network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wdecompose network into AND/OR gates
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wundo last command which changed network
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wverify the equivalence of two sequential networks
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite the current signal transition graph in ASTG format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite mapped network in BDNET format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite network in EQN format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite the STG in KISS2 format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite network in blif format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite network in Espresso PLA format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite network as an Oct view
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wwrite network in SLIF format
.if \n(82<\n(38 .nr 82 \n(38
.nr 38 \wextract sequential don't cares (unreachable states)
.if \n(82<\n(38 .nr 82 \n(38
.82
.rm 82
.nr 38 \w\fBStandard Aliases (cont.)\fP-\n(80-3n-\n(81-3n-\n(82
.if \n(38>0 .nr 38 \n(38/2
.if \n(38<0 .nr 38 0
.nr 81 +\n(38
.nr 82 +\n(38
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr 42 \n(81+(3*\n(38)
.nr 82 +\n(42
.nr TW \n(82
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 515 file Input is too wide - \n(TW units
.ne 27v+2p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\fBStandard Aliases (cont.)\fP
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'alias\h'|\n(41u'command\h'|\n(42u'description
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rsn\h'|\n(41u'reset_name\h'|\n(42u'reset all short names starting from 'a'
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'rt\h'|\n(41u'retime -n\h'|\n(42u'retime an unmapped network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sa\h'|\n(41u'state_assign\h'|\n(42u'create the logic from the STG using state assignment
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'se\h'|\n(41u'stg_extract\h'|\n(42u'extract an STG from the logic
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim\h'|\n(41u'simulate\h'|\n(42u'logic simulation on a network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim0\h'|\n(41u'simplify -d\h'|\n(42u'quick minimization of a node (no don't cares)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim1\h'|\n(41u'simplify -m nocomp -d\h'|\n(42u'complete minimization of a node (no don't cares)
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim2\h'|\n(41u'simplify\h'|\n(42u'single pass minimization with fanin DC-set
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sim3\h'|\n(41u'simplify -m nocomp\h'|\n(42u'complete minimization with fanin DC-set
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sm\h'|\n(41u'state_minimize\h'|\n(42u'minimize the number of states in the STG
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'so \h'|\n(41u'source\h'|\n(42u'source a script file
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sp\h'|\n(41u'speed_up\h'|\n(42u'critical path restructuring to reduce delay
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'sw\h'|\n(41u'sweep\h'|\n(42u'remove buffers, inverters from a network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'td\h'|\n(41u'tech_decomp\h'|\n(42u'decompose network into AND/OR gates
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'u\h'|\n(41u'undo\h'|\n(42u'undo last command which changed network
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'v\h'|\n(41u'verify_fsm\h'|\n(42u'verify the equivalence of two sequential networks
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wa\h'|\n(41u'write_astg\h'|\n(42u'write the current signal transition graph in ASTG format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wb\h'|\n(41u'write_bdnet\h'|\n(42u'write mapped network in BDNET format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'we\h'|\n(41u'write_eqn\h'|\n(42u'write network in EQN format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wk\h'|\n(41u'write_kiss\h'|\n(42u'write the STG in KISS2 format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wl\h'|\n(41u'write_blif\h'|\n(42u'write network in blif format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wp\h'|\n(41u'write_pla\h'|\n(42u'write network in Espresso PLA format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'wo\h'|\n(41u'write_oct\h'|\n(42u'write network as an Oct view
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'ws\h'|\n(41u'write_slif\h'|\n(42u'write network in SLIF format
.ta \n(80u \n(81u \n(82u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'xdc\h'|\n(41u'extract_seq_dc\h'|\n(42u'extract sequential don't cares (unreachable states)
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-33
.bp
.SH DETAILED COMMAND DESCRIPTIONS
.PP
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
act_map  [-h heuristic_num] [-n num_iteration] [-f collapse_fanin]
       [-g gain_factor] [-d decomp_fanin] [-r filename]
       [-M  MAXOPTIMAL] [-qolDsv]
.PP
Routine to find an optimal mapping to the Actel architecture.
The input is the Boolean network and the output
is a netlist and the block count
(reference: An Architecture for Electrically Configurable Gate Arrays,
Gamal et. al., IEEE J. of Solid State Circuits, April 1989, pp. 394-398). 
.PP
\fBact_map\fP synthesizes the given circuit onto Actel
architecture.
It uses a tree-mapping approach to 
cover the subject graph with the pattern graphs.
The pattern graphs are hard-wired into the code 
and so no library is to be read in.
Subject graph and pattern-graphs are in terms of 
2-1 muxes. Subject graph is constructed for each intermediate
node of the network.
Either an OBDD (Ordered BDD) 
and/or a BDD is constructed for each such node.
After the entire 
network is mapped, an iterative_improvement phase may be entered. 

Following options are supported:

.PP
\fB-h heuristic_number\fP specifies which one of the two 
subject_graphs would be constructed.
.br
.PP
heuristic num = 1 => OBDD
.br
.PP
heuristic num = 2 => BDD (default)
.br
.PP
heuristic num = 3 => program decides which one to construct.
.br
.PP
heuristic num = 4 => both are constructed and the one with
lower mapped cost is selected. Gives the best 
result, but typically takes more time.
.br
.PP
\fB-M MAXOPTIMAL\fP constructs an optimal OBDD for a node if number of fanins is 
at most MAXOPTIMAL.
.br
.PP
\fB-n num_iteration\fP specifies the maximum number of iterations
to be performed in the iterative_improvement phase. Each such 
iteration involves a good_decomposition followed by a partial_collapse
routine. Partial_collapse tries to collapse each node into 
its fanouts. Default is -n 0.
.br
.PP
\fB-f collapse_fanin\fP considers only those nodes
for partial_collapse which have fanin no more than collapse_fanin.
(Default: -f 3).
.br
.PP
\fB-g gain_factor\fP makes the program enter the next iteration
only if gain in the present iteration is at least 
(present_cost * gain_factor). (Default: -g 0.01)
.br
.PP
\fB-d decomp_fanin\fP considers only those nodes for good_decomposition
which have fanin greater than or equal to decomp_fanin. (Default -d 4).
.br
.PP
\fB-r filename\fP is the final mapping option.
After mapping, a mapped network would be created, in
which each intermediate node corresponds to one basic block
of Actel architecture.
A file \fBfilename\fP having the netlist description
in a BDNET-like format is also formed.
The pin names of the basic block are the same
as those given in a Figure in the paper on Actel
architecture (reference: An Architecture for Electrically
Configurable Gate Arrays, Gamal et al., IEEE J. Solid State
Circuits, April 1989, pp. 394-398).
.br
.PP
\fB-q\fP makes the program enter a quick_phase 
routine (after iterative_improvement phase), which greedily
finds out if it is beneficial to implement the node in 
negative phase. 
.br
.PP
\fB-D\fP causes a disjoint decomposition routine
to be invoked on the network before mapping starts. 
.br
.PP
\fB-o\fP causes the OR gate in the basic block to be ignored. So mapping is done onto a 
three-mux structure.
.br
.PP
\fB-v\fP turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.
.br
.PP
\fB-s\fP gives the statistics, regarding the block count
of the circuit.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
add_inverter
.PP
Add inverters into the network wherever needed to make each
signal (including the primary inputs) used only in its negative form.
After this command, every literal in a node is in the negative form.
This is the appropriate starting point for the technology mapping step.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
alias [name [string]]
.X1
unalias name ...
.PP
The \fBalias\fR command, if given no arguments, will print the
definition of all current aliases.  Given a single argument, it
will print the definition of that alias (if any).  Given two
arguments, the keyword \fBname\fP becomes an alias for
the command string \fBstring\fP, replacing any other alias with the
same name.
The \fBunalias\fR command removes the definition of an alias.
.PP
It is possible to create aliases that take arguments by using the history
substitution mechanism.  To protect the history substitution character `%'
from immediate expansion, it must be preceded by a `\\' when entering the
alias.  For example:
.IP
.nf
sis> alias read read_\\%:1 \\%:2.\\%:1
sis> alias write write_\\%:1 \\%:2.\\%:1
sis> read blif lion
sis> write eqn tiger
.fi
.PP
will create the two aliases `read' and `write', execute "read_blif
lion.blif", and then execute "write_eqn tiger.eqn".  And...
.fi
.IP
.nf
sis> alias echo2 "echo Hi ; echo \\%* !"
sis> echo2 happy birthday
.fi
.PP
would print:
.IP
.nf
Hi
happy birthday !
.fi
.PP
\fBCAVEAT:\fR Currently there is no check to see if there is a circular
dependency in the alias definition. e.g.
.IP
.nf
sis> alias foo "print_stats -f; print_level -l; foo"
.fi
.PP
creates an alias which refers to itself. Executing the command "foo" will
result an infinite loop during which the commands "print_stats -f" and
"print_level -l" will be executed. 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_add_state [-v debug_level] [-m]
.PP
Adds state signal transitions to the Signal Transition Graph to guarantee
implementability (see \fBastg_state_min\fR for a recommended script file).
.PP
The \fB-m\fR option does not preserve the original ASTG marking, and forces its
re-computation (may be slow; dubious usefulness).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_contract [-f] <signal-name>
.PP
Generate the contracted net for the specified signal of the ASTG.
.PP
The -f option adds the restriction that the contracted net
must also be free-choice.
Chu has conjectured that this restriction may not be necessary,
so it is optional at this time until we have answered this
question.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_current
.PP
Display information about the current ASTG:
its name,
whether it is a free-choice net,
state machine, or marked graph,
and the number of state machine (SM) and marked
graph (MG) components if astg_smc or astg_mgc have
been run on the ASTG.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_encode [-v debug_level] [-h] [-s] [-u]
.PP
Encodes the states of the current State Transition Graph using Tracey's
critical race-free encoding algorithm. Used to perform state encoding for
asynchronous circuits (see \fBastg_state_min\fR for a recommended script file).
.PP
The \fB-h\fR option selects a faster heuristic (that may result in more state
variables).
.PP
The \fB-s\fR option prints out a brief summary of the encoding algorithm
results.
.PP
The \fB-u\fR option allows to enter user-defined codes (for debugging purposes).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_lockgraph [-l]
.PP
Build the lock graph for the current ASTG.
.PP
With the -l option, edges are added to
the ASTG to ensure that the lock graph
is connected, and thus that the ASTG has the Complete State
Coding property.
.PP
If an ASTG has the CSC property, the state of the circuit can
be represented completely by the collection of input, output
and internal signals specified in the ASTG.
This simplifies many synthesis algorithms.
.PP
The algorithm works only for ASTGs that are marked graphs (no choice).
See \fBastg_state_min\fR for a set of commands that
ensure Complete State Coding for more general ASTGs.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_marking [-s] [<marking>]
.PP
Display or set the initial marking of the ASTG.
If no marking is given, the current initial marking is
displayed.
The default format for the marking is the same as for the
\fB.marking\fP command of read_astg.
.PP
The -s option uses a state code format for the marking.
This is a list of signal name and value pairs.
For example, to set an initial state with signal A at
value 0 and B at value 1, use the command:
.br
astg_marking -s A 0 B 1
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_persist [-p]
.PP
Add constraints to make an ASTG persistent.
With the -p option, non-persistent transitions are printed
but the ASTG is not modified.
.PP
For small ASTGs with very high concurrency, enforcing the
ASTG persistency property will partially and sometimes completely
enforce the Complete State Coding property (CSC).
If an ASTG has the CSC property, the state of the circuit can
be represented completely by the collection of input, output
and internal signals specified in the ASTG.
This simplifies many synthesis algorithms.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_print_sg 
.PP
Print the state graph of the current ASTG.  If no state graph is
present, this will create one by token flow.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_print_stat
.PP
Print the statistics of the current ASTG: name of the ASTG file, initial
marking, total number of states in the state graph and the total
number of I/O signals.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_slow [-v debug_level] [-t tolerance] [-s] [-u]
[[-f|-F] external_delay_file] [-d default_external_delay] [-m min_delay_factor]
.PP
Remove hazards from the ASTG implementation, inserting delay buffers after some
ASTG signals. Delays are inserted so that no gate within the circuit
implementation can react as though the ASTG specified ordering of signals is
reversed in time.
.PP
It must be invoked after technology mapping (see \fBastg_to_f\fR for a
recommended script file).
.PP
The \fB-m\fR option specifies the amount by which all MINIMUM delays are
MULTIPLIED (this until the delay computation will understand min/max delays).
Of course 0.0 < min_delay_factor <= 1.0.  Default value: 1.0.
.PP
The \fB-t\fR option specifies the tolerance to be used during the hazard check
procedure (the larger the specified value, the more conservative is the
algorithm). Default value: 0.0.
.PP
The \fB-s\fR option specifies not to use the shortest-path algorithm when
computing the delays in the network. This might result in being overly
pessimistic (this option is only experimental).
.PP
The \fB-f\fR option specifies a file name to search for the minimum
delays between output signals and input signals of the ASTG (i.e. for those
signals that are not being synthesized). This can be useful if some information
about these signals is known either from the specification or from the
synthesis of another sub-component of the total asynchronous system. 
.PP
The file can also be
updated with the minimum delays between each input signal and each output
signal if the \fB-F\fR option is used in place of \fB-f\fR.
This allows for separate synthesis of various sub-components of an
asynchronous system. In this case iteration might be necessary to obtain
optimal results, and a warning message is issued when the stored information
is changed, and  a new iteration is required.
.PP
The \fB-u\fR option specifies not to remove hazards, but only to update the
external elay file (if appropriate). This can be used to remove hazards from a
set of Signal Transition Graphs that are synthesized separately (e.g. by
contraction). In this case, a first round of synthesis can be performed
on each Signal Transition Graph, followed by \fBastg_slow\fR 
with the \fB-F\fR and the \fB-u\fR options, to store the information on the
delay of the function implementing each signal. Then \fBastg_slow\fR can be
iterated among the Signal Transition Graphs with the \fB-F\fR option only until
convergence is obtained. The results should be comparable with synthesis and
hazard removal from a single Signal Transition Graph, but can be considerably
faster for large specifications.
.PP
The \fB-d\fR option specifies the default minimum delay between output signals
and input signals of the ASTG (if no information can be obtained from the above
described file). The default value is 0.0 (i.e. the environment responds
instantaneously), but this can be overly pessimistic, and result in an
unnecessary slow and large implementation.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_state_min [-v debug_level] [-p minimized_file] [-c "command"]
[-b|-B] [-g|-G] [-u] [-m|-M] [-o #] [-f signal_cost_file]
.PP
Minimizes the current State Transition Graph and derives the information
required to encode the associated Signal Transition Graph.
The complete sequence of actions to implement a Signal Transition Graph that
does not have Complete State Coding is as follows:
.br

.br
astg_to_stg -m
.br
astg_state_min
.br
astg_encode
.br
astg_add_state
.br

.br
astg_to_f
.br
 ...
.PP
The \fB-f\fR option selects a signal cost file. 
This file should contain one line of the form
.br
<signal name> <cost>
.br
(e.g. "bus_ack 10") for each signal in the ASTG. The encoding algorithm 
minimizes the sum of the weights of signals that follow state transitions.
Hence this file can be used to strongly favor or disfavor changing the
predecessors of the transitions of a signal. 
.PP
By default, output signals have a cost of one and input signals have a
cost equal to the number of output signals plus one. In this way, no input
signal is constrained, if possible.
.PP
The command may emit a series of diagnostic messages of the form:
.br
warning: the STG may not be live (multiple exit point): may need constraint
<signal 1> -> <signal 2>
.br
These messages may or may not cause a failure (diagnosed as internal error)
later on during \fBastg_add_state\fR. In case of failure, \fBone\fR of the
required constraints (ideally the constraint that least decreases the circuit
performance due to the reduction in concurrency) should be added to the ASTG.
The procedure should be repeated until no more such messages occur.
.PP
The options listed below are not generally useful except for debugging purposes
or to obtain faster (but potentially less optimal)
results for large Signal Transition Graphs.
All algorithm speed indications reflect average case analysis.
.PP
The \fB-B\fR and \fB-b\fR options select Binary Decision Diagrams
as internal data structure to find the encoding information (both are generally
slower than the default selection, but \fB-b\fR is generally
faster than \fB-B\fR).
.PP
The \fB-M\fR and \fB-m\fR options select Sparse Matrices
as internal data structure to find the encoding information (both are generally
slower than the default selection, but \fB-m\fR is generally
faster than \fB-M\fR). If \fB-M\fR is selected, then \fB-o\fR can be used to
define some further internal options (this is strongly discouraged).
.PP
The \fB-G\fR and \fB-g\fR options select a greedy (\fB-g\fR) or very greedy
(\fB-G\fR) heuristic
to find the encoding information (both faster and looser than the default
selection).
.PP
The \fB-u\fR option selects a generally slower
heuristic to find the encoding information.
.PP
The \fB-c\fR option allows to use a different minimizer from the default
choice. The minimizer must be able to read and write .kiss format and to write
equivalence class information in the output file, in the following format:
.br
#begin_classes <number of classes>
.br
# <state name> <class number>
.br
 ...
.br
#end_classes
.PP
The \fB-p\fR option avoids calling the minimizer altogether, just reading in
the specified minimized file (in .kiss format with equivalence class
information).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_stg_scr [-v debug_level] 
.PP
Transforms the current State Transition Graph into one that satisfies the
Single Cube Restriction. 
.PP
The Single Cube Restriction means that each state has exactly one associated
value of input signals under which it is entered. The result is accomplished by
state duplication, but the result may be non-minimal.
This command is required (and useful) before \fBstg_to_astg\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_syn [-m] [-r] [-v debug_level] [-x]
.PP
Synthesize from the current signal transition graph a two-level implementation 
which is hazard-free under the unbounded gate delay model (i.e., gates have
unbounded delays, wires have zero delays).
.PP
The synthesis is performed in two steps.  The first step derives a
state graph from the ASTG by performing a reachability analysis.  If no
initial marking is given, then \fBastg_syn\fR will try to find a live,
safe initial marking.  The second step uses the state graph generated
in step one to perform hazard analysis and synthesis.  All static
hazards and critical races are removed.  \fBastg_syn\fR tries to
remove all dynamic hazards arising from multiple input or output
changes.  When it cannot remove such hazards, it will print the terms
which can potentially produce hazards and the conditions under which
hazards can be produced.  From this user can remove the dynamic
hazards by removing some concurrency.
The resulting implementation may be neither prime nor irredundant.
.PP
The following options are not intended for general use.
.PP
The \fB-m\fR does not perform cube reduction and always returns a
prime cover implementation free of static hazards.  As a consequence,
dynamic hazards due to multiple input/output changes may not be
removed.
.PP
The \fB-r\fR option runs ESPRESSO in single-output mode.   
The implementation will be prime and irredundant, but may have static hazards
and dynamic hazards.
.PP
The \fB-v\fR option specifies the debug level.
.PP
The \fB-x\fR assumes that a state graph has already been derived, and
perform synthesis directly from the given state graph.   State graph can be
derived by using \fB_astg_flow\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_to_f [-v debug_level] [-r] [-s signal_name] [-d]
.PP
Generate an initial two-level implementation of each output signal specified by
the current Signal Transition Graph.
.PP
If the initial marking is not defined, then a valid marking is searched for.
The list of potential hazards, used by \fBastg_slow\fR, is also produced.
.PP
One primary input is generated for each signal (both input and output)
specified by the ASTG, with the same name as the signal (and "_" appended if the
signal is an output).
.PP
One primary output is generated for each output signal 
specified by the ASTG, with the same name as the signal.
The primary output is driven directly by the primary input.
.PP
One asynchronous latch is generated for each output signal specified by the
ASTG, connecting the combinational logic function implementing the signal (a
"fake" primary output with the same name as the signal and "_next" appended) and
the corresponding primary input.
.PP
If some signal is not used inside the combinational logic, then the
corresponding primary input and latch is not created (unless the option
\fB-r\fR is specified).
.PP
The \fB-s\fR option adds a set of fake primary outputs that ensure that the
named signal is implemented as a Set-Reset flip-flop. If, in addition,
the \fB-d\fR option is specified, the functions for the Set and Reset input are
made disjoint. This may increase the implementation cost, but reduces its
sensitivity to dynamic hazards.
.PP
An error message results if either no valid marking is found (in which case it
might be advisable to define it in the ASTG specification file) or the ASTG does
not have the Compatible State Coding property (i.e. if two markings with
different sets of enabled output signals have the same binary label).
See \fBastg_state_min\fR for a recommended action in the latter case.
.PP
A typical ASTG synthesis and optimization script should look like:
.br
astg_to_f
.br

.br
gkx -ab
.br
resub -ad; sweep
.br
gcx -b
.br
resub -ad; sweep
.br
eliminate 0
.br
decomp -g *
.br
eliminate -1
.br

.br
map
.br
astg_slow 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
astg_to_stg [-v debug_level] [-m]
.PP
Generate a State Transition Graph
from the current Signal Transition Graph.
The State Transition Graph has one input signal for each signal in the Signal
Transition Graph (both input and output), and one output signal for each output
signal in the Signal Transition Graph.
.PP
If the initial marking is not defined, then a valid marking is searched for.
.PP
An error message results if no valid marking is found (in which case it
might be advisable to define it in the ASTG specification file).
.PP
The \fB-m\fR option additionally performs a pre-minimization step that produces
a State Transition Graph suitable for subsequent state encoding commands (such
as, e.g., \fBastg_state_min\fR).
.XX
atpg [-fFhrRpt] [-d RTG_depth] [-n n_fault_sim] [-v verbosity_level] 
     [-y random_prop_depth] file
.PP
Perform test generation for both combinational and sequential circuits using 
random test generation, deterministic test generation, and fault simulation. Deterministic test generation is accomplished by one of two methods. The 
first method is a three-step test generation algorithm consisting of 
combinational test generation (assuming that latch outputs are controllable, 
and that latch inputs are observable), followed by state justification and propagation, when necessary. The combinational test generation is 
accomplished using Boolean satisfiability. Justification and propagation are 
performed using implicit state transition graph traversal techniques. If the 
three-step method does not generate a test for a fault, then the product of 
the good and faulty circuit is built and traversed, as in sequential circuit 
verification. If this traversal proves the circuits equivalent, then the 
fault is redundant; otherwise any differentiating sequence is a test for the 
fault.
.PP
Fault collapsing is performed before test generation, across only simple 
gates. Both fault equivalence and fault dominance are used to reduce the 
fault list.
.PP
For combinational circuits, external don't cares are automatically taken 
into account when the don't care network is attached to the care network. The PI's and PO's of the external don't care network (when it is not NIL) must match exactly with the care network. That is, the don't care network cannot specify only a subset of the PI's or PO's of the care network. If this condition is not met,
then the atpg package automatically adds dummy primary inputs and outputs to the
external don't care network.
.PP
Reverse fault simulation is performed as a post-processing step to reduce
test set size.
.PP
The \fB-f\fP option causes the atpg not to perform fault simulation of 
deterministically-generated tests on untested faults. 
.PP
The \fB-F\fP option causes the atpg not to use reverse fault simulation. 
.PP
The \fB-h\fP option restricts the boolean satisfiability algorithm to not use 
non-local implications. Four greedy ordering heuristics are tried in this case 
instead of the default of eight. Hard-to-test faults that can only be tested 
with non-local implication information are aborted by this option.
.PP
The \fB-r\fP option causes the atpg not to perform random test pattern
generation.
.PP
The \fB-R\fP option causes the atpg not to perform random propagation. 
(Deterministic propagation is still attempted).  
.PP
The \fB-p\fP option causes the atpg not to build any product machines. Thus, 
neither deterministic propagation nor good/faulty product machine traversal
will be performed. 
.PP
The \fB-t\fP option first converts the network to arbitrary fanin AND and
OR gates. The decomposed network is returned.
.PP
The \fB-d\fP option allows the specification of the length of the random
sequences applied during random test generation. The default length is
the depth of the circuit's state transition graph. 
.PP
The \fB-n\fP option allows the specification of the number of sequences
to fault simulate at one time during fault simulation. The default is the
system word length.  
.PP
The \fB-v\fP allows the specification of the verbosity level of the output.
.PP
The \fB-y\fP option allows the specification of the length of the random
sequences applied during random propagation. The default length is 20. 
.PP
If \fBfile\fP is specified, test patterns are written out to the given file.
.PP
Note: in order to use this command with sequential circuits, the circuit
reset state must be specified in the circuit input file.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
bdsyn
.PP
A special command exported for use by bdsyn(1).  Not for general use.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
buffer_opt [-l #] [-f #] [-c] [-d] [-T] [-L] [-v #] [-D] node-list
.PP
Builds fanout trees for the nodes in the \fBnode-list\fR.
If no nodes are specified selects the nodes to be buffered
in order to improve performance of the entire network. The
network is assumed to be mapped.
.PP
The \fB-l #\fR option specifies the number of fanouts which
a node can have so as to be eligible for buffering. The
default is 2, hence any multi-fanout node is a candidate for 
buffering.
.PP
The \fB-f #\fR option specifies the transformations to use. Set the
three least significant bits indicate the use (value == 1) of
the transformations. xx1 to use the \fIrepower\fR transformation,
x1x to use an \fIunbalanced\fR transformation and 1xx to use the
\fIbalanced\fR distribution of signals. More than one transformation
can be set active. Thus to allow the algorithm full flexibility use
the value = 7 (111 in binary notation) which is also the default.
.PP
The \fB-c\fR option specifies that one pass be carried out.
The default is to iterate till no improvement is achieved.
.PP
The \fB-d\fR option allows the complex gates to be decomposed
into smaller ones so as to increase drive capability. By default
the complex gates are retained.
.PP
The \fB-L\fR option traverses the network from outputs to
inputs ensuring that for every node, the gate that implements it
does not drive a load greater than the \fImax_load\fR limit
specified for that gate. \fBTHIS OPTION IS NOT YET IMPLEMENTED\fR.
.PP
The \fB-T\fR option displays the circuit performance as the 
iterations progress. If the required times at the outputs are
not specified the circuit delay is shown, else the minimum
slack value is displayed.
.PP
The \fB-v #,-D\fR option are for debugging. The \fB-v #\fR option
is the most verbose and the amount of verbosity can be increased
by letting the argument for \fB-v\fR range from 1 to 100.
.XX
c_check -[nd] -[SH]#.#
.PP
Verifies that the given circuit satisfies the constraints for correct
clocking. By default the circuit is assumed to be mapped to a library.
Use the \fB-n\fR option to use the \fIunit-fanout\fR delay model. 
.PP
The user can give global set-up (and hold) times for all memory
elements using the \fB-S\fR (\fB-H\fR) option. By default it computes
the set-up and hold times from the library. \fIIf the optimal clocking
scheme was found using the c_opt command\fR make sure you use the same
delay model!
.PP
The \fB-d value\fR selects the debug level. The range is 1-5.
.XX
c_opt -[nGI] -[dSHmM]#.#
.PP
Computes the optimal clock for a given clocking scheme.
Finds rise and fall times for the clock events. A single clock
multi-phase clocking scheme is assumed.
.PP
The algorithm works on mapped and unmapped networks (default is
mapped). Note that to ensure every node is mapped, you should read in
the blif file, read in the library, map the circuit and then run the
optimal clocking algorithm. \fIIt is a known fact that reading in a 
mapped netlist often causes some nodes to remain un-mapped\fR. The
command will abort in such a case. The \fB-n\fR option is used for the
\fIunit-fanout\fR delay model. 
.PP
By default the algorithm uses a special Linear program solver based on the
Floyd-Warshall algorithm. An alternate formulation using binary search
is available (\fB-B\fR) as long as \fIno minimum duty cycle constraints
are imposed\fR. 
.PP
The \fB-I\fR option is used for \fI2 phase inverted clocking schemes only\fR.
.PP
The user can give global set-up (and hold) times for all memory
elements using the \fB-S\fR (\fB-H\fR) option. By default it computes
the set-up and hold times from the library.
.PP
The \fB-m\fR option permits the user to specify a minimum phase
separation as a fraction of the clock cycle. Similarly the \fB-M\fR 
option sets the maximum phase separation as a fraction of the clock
cycle.
.PP
The \fB-d value\fR selects the debug level (range 0-4).

This routine runs faster (upto 2X) when compiled with the priority
queue library from octtools (use flag -DOCT when compiling this
directory).



.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
chng_clock
.PP
Toggles the setting of the clock between the user-specified
clock settings (specified in the blif file) and the working
values (generated by algorithms inside \fBSIS\fR).
.PP
All algorithms use the current setting as input. If the
algorithms modify the clocking scheme or the cycle-time they
write the modified clocking scheme into the working fields.
Thus, to write out the blif file containing the clock scheme 
generated by algorithms inside \fBSIS\fR, the setting must first be
set to the working one and then \fBwrite_blif\fR must be invoked. 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
chng_name
.PP
Toggles the network between 
long-name mode (user supplied names) and short-name mode
(automatically generated single-character names).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
collapse [n1] [n2]
.PP
Collapse nodes in the network.  With no arguments, the entire network is
collapsed into a single-level of functions (i.e., two-level form).  
Each output will be expressed in terms of the primary inputs.
.PP
Given a single node,
that function is collapsed until it is represented entirely in terms of
primary inputs.  
.PP
Given two arguments, it is assumed that the second node
is a fanin of the first node.  In this case, this dependency is removed
(the first node is expressed without the second node as a fanin).
.PP
Please note that this command negates any mapping that may have been done
at an earlier time.
.PP
Caution should be taken when collapsing network to two levels because
the two level representation may be too large.
The alternative is to use \fBeliminate\fR (selective collapse).
Refer to \fBeliminate\fR for the details.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
constraints [node_1....node_n]
.PP
Print the values of the various delay constraints for the nodes in the
argument list, which must be either inputs or outputs.  Also prints
the default values of the default delay parameters for the network.
Used to check the values set by \fBset_delay\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
decomp [-gqd] [node-list]
.PP
Decompose all the nodes in the \fBnode-list\fR.  If the \fBnode-list\fR
is not specified, all the nodes in the current network will be
decomposed.  Decompostion will factor nodes and make the divisor a new
node within the network, re-expressing other nodes in terms of this
newly introduced node.  It is one of the transforms used to break
down large functions into smaller pieces, usually at the cost of
introducing a few more literals.
.PP
If the \fB-q\fR option (the default) is specified, the \fIquick decomp\fR 
algorithm is used which
extracts out an \fIarbitrary\fR kernel successively.  Because
of the fast algorithm for generating an arbitrary kernel,
\fBdecomp -q\fR is very fast compared with the \fBdecomp -g\fR.
In most cases, the result is very close.
This command is recommended at the early phase of the optimization.
.PP
If the \fB-g\fR option is specified, the \fIgood decomp\fR
algorithm is used which
successively extracts out the \fIbest kernel\fR until the function is
factor free, and applies the same algorithm to all the kernels just extracted.
This operation will give the best \fIalgebraic\fR decomposition for the nodes.
But, since it generates all the kernels at each step, it takes more
CPU time.  In general, \fBdecomp -q\fR should be used in the early
stage of the optimization. Only at the end of the optimization, should
\fBdecomp -g\fR be used.
.PP
If the \fB-d\fR option is specified, the disjoint decomposition
is performed.  Currently, the disjoint decomposition is limited
to the following simple algorithm:  It partitions the cubes
into sets of cubes having disjoint variable support, creates
one node for each partition, and a node (the root of the 
decomposition) which is the OR of all the partitions.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
echo args ...
.PP
Echoes the arguments to standard output.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
eliminate [-l limit] thresh
.PP
Eliminate all the nodes in the network whose 
value is less than or equal to \fBthresh\fR.
The value of a node represents the number of literals saved
in the literal count for the network by leaving the
node in the network.
If the value is less than (or equal to) the threshold, the node
will be eliminated by collapsing the node into each of its fanouts.
A primary input or a primary output will not be eliminated.
.PP
The value of the node is approximated based on
the number of times the node is used
in the factored form for each of its fanouts.
Note that if a node is used only once, its value is always -1.
.PP
\fBlimit\fR is used to control the maximum number of cubes
in any node.  The default is 1000.  Using a very large \fBlimit\fR
may result in collapsing the network to two levels.  In general,
if the circuit is collapsible, the command \fBcollapse\fR is
more efficient.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
env_seq_dc [-v n] filename.blif
.PP
This command extracts sequential don't cares based on unreachable
states. It builds the product of the current network with the network
passed as argument, computes the set of reachable states of the
product, extracts from that the set of reachable states of the
original network, and uses its complement to build a don't care
network for the current network. Any previous don't care network is
discarded. 
.PP
\fBfull_simplify\fR or \fBequiv_nets\fR should be run afterwards to
exploit these don't cares.
.PP
External inputs of the current network are connected to matching
external outputs of the network passed as argument and vice-versa.
Nodes match if and only if they have the same name.
.PP
\fB-v\fR allows the specification of the verbosity level of the output.
The default value is 0.
.PP
The method used to compute the set of reachable states is the
\fBproduct\fR method. See \fBextract_seq_dc\fR for details.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
env_verify_fsm [-v n] [-V] fsm.blif env.blif
.PP
Verify the equivalence of two synchronous networks in a given environment. 
The current network is compared with \fBfsm.blif\fR under the
environment defined by the \fBenv.blif\fR network. 
The environment is a sequential circuit that generates the inputs of
the circuits under verification, and possibly takes some inputs from
them. What is verified is that the current network and the
\fBfsm.blif\fR network are substituable for one another when used in
the context of the \fBenv.blif\fR network.
.PP
The input and output variables from the three networks are
matched by names. It is assumed that all the latches in both designs
are clocked by a single, global clock.
The verification is done by implicitly enumerating all the
states in the product machine, and checking that the outputs
are equivalent for all reachable state pairs starting
from the initial state of the product machine.
.PP
\fB-v\fR allows specification of the verbosity level of the output.
.PP
By default, the command returns an error status if the verification fails.
When option \fB-V\fR is used, it returns an error status if the verification succeeds.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
equiv_nets [-v n]
.PP
This command simplifies the network using net equivalence.
With \fBfull_simplify\fR, it is one of the two routines able to take
advantage of network don't cares.  
.PP
\fBequiv_nets\fR groups all nets of the network by equivalence classes.
Two nets are equivalent if and only if they always compute the same
function with respect to the external care set. It only uses input
don't cares, not observabiilty don't cares.
.PP
For each equivalence class, \fBequiv_nets\fR selects a lowest cost
net, and moves the fanout of all the other nets of the equivalence
class onto the lowest cost net.
.PP
Finally, it calls the command \fBsweep\fR.
.PP
\fB-v\fR allows the specification of the verbosity level of the output.
The default value is 0.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
espresso
.PP
Collapse the network into a PLA, minimize it using \fIespresso\fR,
and put the result back into the multiple-level \fInor-nor\fR form.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
extract_seq_dc [-o depth] [-v n] [-m method]
.PP
Extract sequential don't cares based on unreachable states.
The unreachable states are computed by
implicitly enumerating the set of
reachable states in the circuit starting from an initial state
and then computing the inverse of that set.
\fBfull_simplify\fR or \fBequiv_nets\fR should be run afterwards to
exploit these don't cares.  
.PP
\fB-o depth\fR allows the specification of the depth of search for good
variable ordering.
A larger value for depth will require more CPU time but determine
a better ordering.
The default value is 2.
.PP
\fB-v\fR allows specification of the verbosity level of the output.
.PP
The \fB-m\fR option specifies \fBmethod\fR for determining
the reachable states.
\fBconsistency\fR builds the entire transition relation
and uses it to determine the reached states.
\fBbull\fR does output cofactoring to find the reachable
states.
The \fBproduct\fR method is similar to the \fBconsistency\fR method but
input variables are smoothed as soon as possible as the characteristic
function is being built.
This makes the size of the resulting BDD representing the
characteristic function of the transition relation smaller.
The default method is \fBproduct\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
factor [-gq] node-list
.PP
Throw away the old factored forms and factor each node in the 
\fBnode-list\fR, and store the factored forms with the nodes.
If the \fB-q\fR option is specified, the \fIquick factor\fR algorithm
is used to factor the node.
If the \fB-g\fR option is specified, the \fIgood factor\fR
algorithm is used to factor the node.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
fanout_alg [-v] alg_list
.PP
Activates selectively one or more fanout algorithms. For a list of 
fanout algorithms known to the system, use the \fB-v\fR option.
The algorithms activated are the ones specified in the list.
One algorithm, \fInoalg\fR, is always active.
\fItwo_level\fR 
is a fast, area efficient algorithm. The best results are
obtained with \fItwo_level\fR, \fIbottom_up\fR, \fIlt_trees\fR,
and \fImixed_lt_trees\fR.
.PP
Fanout optimization itself is performed using the \fBmap\fR command.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
fanout_param [-v] fanout_alg [property value]
.PP
Changes the default parameter values associated with specific 
fanout algorithms. For a list of these parameters and their values,
use the \fB-v\fP option with a fanout algorithm.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
force_init_0
.PP
This command replaces all latches initialized to 1 by latches
initialized to 0. It inserts an inverter before and after the latch
to maintain circuit behavior. 
.PP
This command is useful for certain types of FPGA architectures
which do not support the initialization of latches to 1.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
free_dc
.PP
Frees the don't care network associated with a network.
This command is used for debugging and experimental purposes.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
full_simplify [-d][-o ordering] [-m method] [-l] [-v verbose]
.PP
Simplify each node in the network using the local don't cares
generated in terms of fanins of each node.
First compatible
observability plus external don't cares are generated for
each node in terms of primary inputs.
Then the image
computation techniques are used to map these don't cares
to the local space of each node.
This technique removes
most redundancies in the network.
The satisfiability don't cares
for a subset of the nodes in the network which have the same 
support as the node being simplified is also generated.
An ordering is given to the nodes of the network
and local don't cares for the nodes are computed according
to that ordering.
Each node is simplified using its local don't cares and an
appropriate satisfiability don't care subset.

.PP
\fB-d\fR If this option is used no observability don't cares are computed.
In this case the local don't cares are only the unreachable points
in the local space of each node (a subset of the satisfiability
don't care set).

.PP
\fB-o\fR Used for BDD ordering. If 0 (default) is used, variables
are ordered based on their depth. If 1 is used, the level of
a node is used for its ordering.

.PP
\fBmethod\fR specifies the algorithm used to minimize the nodes.
\fIsnocomp\fR (default) invokes a single pass minimization procedure that does
not compute the complete offset.
\fInocomp\fR invokes the full minimization procedure (ala ESPRESSO) but does
not compute the complete offset.
\fIdcsimp\fR invokes single pass tautology-based minimizer.

.PP
\fB-l\fR generates fanin don't cares only for nodes
with the same or subset support as the node being minimized
which have level less than the node being minimized. The level
is the largest number of nodes on the longest  path from the node to
a primary input.

.PP
\fB-v\fR prints out extra info for debugging the code.

 
SIS(1)              UNIX Programmer's Manual               SIS(1)
 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
fx [-o] [-b limit] [-l] [-z]
.PP
Greedy concurrent algorithm for finding the best double cube divisors and
single cube divisors.
Finds all the double cube and single cube divisors
of the nodes in the network.
It associates a cost function to each node,
and extracts the node with the best cost function greedily.
.PP						 
The \fB-o\fP option only looks for  0-level two-cube divisors.
.PP
The \fB-b\fP option reads an upper bound for the number of divisors
generated. The default value is 50000. This is because the 
number of divisors in some cases can grow very large.
.PP
The \fB-l\fP option changes the level of each node in the network as allowed
by the slack between the required time and arrival time at that node. 
.PP
The \fB-z\fP option uses zero-weight divisors (in addition to divisors with
a larger weight).  This means that divisors that contribute zero gain to
the overall decomposition are extracted.  This may result in an overall
better decomposition, but take an exhorbitant amount of time.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
gcx [-bcdf] [-t threshold]
.PP
Extract common cubes from a network, re-express the network
in terms of these cubes, and in the process cut down on the
number of literals needed in the network.
.PP
The \fB-b\fP option chooses the best cube at each step when examining
possible cubes to be extracted; otherwise, the more efficient \fIping-pong\fP
algorithm is used to find a good (but not necessarily the best) cube
at each step.
.PP
The \fB-c\fP option uses the complement of each cube as well as the cube
when dividing the new cube into the network.
.PP
The \fB-f\fP option uses the number
of literals in the factored form for the
network as a cost function for determining the best cube to be extracted.
.PP
The \fB-t\fP option sets a threshold such that only a cube with a value
greater than the threshold will be extracted.  By default, the threshold is
0, so that all possible cube divisors are extracted.
.PP
The \fB-d\fP option enables a debugging mode which traces the execution
of gcx.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
gkx [-1abcdfo] [-t threshold]
.PP
Extract multiple-cube common divisors from the network.
.PP
The \fB-a\fP option generates all kernels of all function in the network
when building the kernel-intersection table.  By default, only level-0
kernels are used.
.PP
The \fB-b\fP option chooses the best kernel intersection as the new
factor at each step of the algorithm; this is done by enumerating and
considering each possible kernel intersection, and choosing the best.
By default, the more efficient \fIping-pong\fP algorithm is used to
find a good (but not necessarily the best) kernel intersection.
.PP
The \fB-c\fP option uses the new factor and its complement when attempting
to introduce the new factor into the network.
.PP
The \fB-d\fP option enables debugging information which traces the execution
of the kernel extract algorithm.
.PP
The \fB-f\fP option uses the number of literals in the factored form for
the network as the cost function when determining the value of a
kernel intersection; by default, the number of literals in the sum-of-products
form for the network is used.
.PP
The \fB-o\fP option allows for overlapping factors.
.PP
The \fB-t\fP option sets a threshold such that divisors are extracted
only while their value exceeds the threshold.  By default, the threshold is 0
so that all possible multiple-cube divisors are extracted from the network.
.PP
The \fB-1\fP option performs only a single pass over the network.  By default,
the kernel extract algorithm is iterated while there are still divisors whose
value exceeds the given threshold.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
help [-a] [command]
.PP
Given no arguments, help prints a list of all commands known to the
command interpreter.  The \fB-a\fP option provides a list of all
debugging commands, which by convention begin with an underscore.
If a command name is given,
detailed information for that command will be provided.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
history [-h] [num]
.PP
Lists previous commands and their event numbers.
The \fB-h\fP option suppresses printing the event number.
If \fBnum\fP is specified, lists the last \fBnum\fP events.  Lists the last
30 events if \fBnum\fP is not specified.
.PP
History Substitution:
.PP
The history substitution mechanism is a simpler version of the csh history
substitution mechanism.  It enables you to reuse words from previously typed
commands.
.PP
The default history substitution character is the `%' (`!' is default for shell
escapes, and `#' marks the beginning of a comment). This can be changed using
the "set" command. In this description '%' is used as the history_char.
The `%' can appear
anywhere in a line.  A line containing a history substitution is echoed to
the screen after the substitution takes place.  `%' can be preceded by a
`\\' in order to escape the substitution, for example, to enter a `%' into
an alias or to set the prompt.
.PP
Each valid line typed at the prompt is saved.  If the \fBhistory\fP variable
is set (see help page for \fBset\fP), each line is also echoed to the history
file.  You can use the "history" command to list the previously typed
commands.
.PP
Substitutions: at any point in a line these history substitutions are
available
.ta .5i 1.5i
.PP
.nf
	%:0	Initial word of last command.
	%:n	n'th argument of last command.
	%$	Last argument of last command.
	%*	All but initial word of last command.

	%%	Last command.
	%stuf	Last command beginning with "stuf".
	%n	Repeat the n'th command.
	%-n	Repeat the n'th previous command.
	^old^new	Replace "old" w/ "new" in previous command.

	Trailing spaces are significant during substitution.
	Initial spaces are not significant.
.fi
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
invert node-list
.PP
Invert each node in the \fBnode-list\fR.  It is used when
the complement of a node is to be implemented.  Note that
it does not change the logic function of the current Boolean
network, but will have an effect on the structure of the network.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
invert_io node-list
.PP
This command reverses the polarity of the specified nodes.
The nodes have to be external primary inputs or external primary outputs. 
.PP
The polarity inversion is done by adding an inverter before a primary output or
after a primary input.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
ite_map  [-n num_iter] [-C cost_limit] [-f collapse_fanin]
         [-m map_method] [-d decomp_fanin] [-M  MAXOPTIMAL] [-clorsvD]
.PP
Routine to find an optimal mapping to Actel's ACT1 architecture.
The input is the Boolean network and the output
is a netlist and the block count
(reference: An Architecture for Electrically Configurable Gate Arrays,
Gamal et. al., IEEE J. of Solid State Circuits, April 1989, pp. 394-398). 
.PP
\fBite_map\fP synthesizes the given circuit onto Actel ACT1
architecture.
The pattern graphs are hard-wired into the code 
and so no library is to be read in. Each intermediate 
node of the network is checked to see if it matches onto one ACT1
module. This check is done using a Boolean matching algorithm.
If not, then a subject graph is constructed for the node function.
The subject graph (as well as the pattern-graphs) is in terms of 
2-1 muxes: it uses ITEs (if-then-else DAGs) and ROBDDs (Reduced
Ordered BDDs) for the mapping. After an initial mapping of the
network,  an iterative_improvement phase may be entered. Local collapse and
decomposition operations are performed for better quality.

Following options are supported:

.PP
\fB-m map_method\fP specifies which one of the two 
subject_graphs would be constructed.
.br
.PP
map_method = 1 => Standard mapping for each node.
.br
.PP
map_method = 2 => construct a sub-network from each node. Map the
sub-network using iterative improvement and finally replace the node
with the mapped sub-network.
.br
.PP
\fB-n num_iteration\fP specifies the maximum number of iterations
to be performed in the iterative_improvement phase. Default is -n 0.
.br
.PP
\fB-F collapse_fanins_of_fanout\fP used in partial collapse. Collapses
a node into fanouts only if after collapsing, each fanout has at most
collapse_fanins_of_fanout fanins (Default: -F 15).
.br
.PP
\fB-C cost_limit\fP in partial collapse, collapse a node only if its
cost is at most cost_limit (Default: -C 3).   
.br
.PP
\fB-f collapse_fanin\fP considers only those nodes for partial
collapse which have at most collapse_fanin fanins (Default: -f 3). 
.br
.PP
\fB-d decomp_fanin\fP considers only those nodes for decomposition in
iterative improvement which have fanin greater than or equal to
decomp_fanin. (Default -d 4).
.br
.PP
\fB-M MAXOPTIMAL\fP constructs an optimal ROBDD (if the ROBDD option
is selected) for a node if number of fanins is at most MAXOPTIMAL.
.br
.PP
\fB-r\fP is the final mapping option. After initial mapping and
possible iterative improvement, a mapped network is created in 
which each intermediate node corresponds to one ACT1 module. If not
specified, the network may not have a one-to-one correspondence with
the ACT1 module.
.br
.PP
\fB-D\fP selects the decomposition method. If specified, computes a
factored form of the node and then constructs ITE for each factor. 
.br
.PP
\fB-c\fP causes the matching algorithm to be exact. If not
specified, matching is approximate.
.br
.PP
\fB-o\fP causes the OR gate in ACT1 to be ignored. So mapping is done onto a 
three-mux structure.
.br
.PP
\fB-v\fP turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.
.br
.PP
\fB-s\fP gives the statistics, regarding the block count
of the circuit.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
latch_output [-v n] node-list
.PP
The nodes passed as argument should be external primary outputs.
This command forces the listed external primary outputs to be fed by a
latch. This is accomplished by moving latches forward by retiming.
.PP
The command fails if there is a combinational dependency between an
external primary input and one of the specified primary outputs.
.PP
This function is useful to guarantee that certain outputs will not
glitch. It is handy if that output is to control an external device
such as the write enable signal of a memory chip.
.PP
\fB-v\fR allows the specification of the verbosity level of the output.
The default value is 0.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
map [-b #][-f #][-i][-m #][-n #][-r][-s][-p][-v #] [-A][-B #][-F][-G][-W]
.PP
Perform a technology mapping on the current network.  A library must be read
using the \fBread_library\fR command before mapping can be performed.
The result
of the mapping may become invalidated if a command such as \fBplot\fR or
\fBprint_stats -f\fR is executed which computes a factored form
representation of
every node.
.PP
To produce a minimum area circuit with no consideration for load limits, the
recommended option is \fBmap -m 0\fR. 
.PP
To produce a minimum area circuit that respects load limits, the recommended
option is \fBmap -m 0 -AF\fR.   Use \fB_check_load_limit\fR
command to check for
load limit violations.
.PP
To produce a minimum delay circuit that respects load limits, the recommended
option is \fBmap -n 1 -AFG\fR.
To specify required times in order to allow the
mapper to trade off delay and area, use the \fBset_delay\fR command. 
.PP
Details about the meanings of the various options follow.
.PP
The \fB-b n\fP sets the number by which the load value
should be multiplied in case of a load limit violation during fanout optimization.
.PP
The \fB-f n\fP option controls the internal fanout handling. A value
of '0' disables it completely (i.e. the mapping is strictly
tree-based).  
A value of '1' enables an heuristics approximating the
cost of the previous tree at fanout branches. 
A value of '2' enables
the usage of cells with internal fanout (such as EXOR and
MULTIPLEXER). A value of '3' (default) enables both.  None of these
values is guaranteed to give the best solution in all cases, but '3'
usually does. A warning is issued if the current value can give bad
results with the current network (use \fBundo\fR before mapping
again).
.PP
The \fB-i\fP option disables the \fIinverter-at-branch-point\fR heuristic.
It is intended for experimentation with different mapping heuristics.
.PP
The \fB-m\fP option controls the cost function used for a simple version of the
tree covering algorithm.  A mode of '0' (the default) minimizes the area of the
resulting circuit.  A mode of '1' minimizes the delay of the resulting circuit
(without regard to the total area).  An intermediate value uses as cost
function a linear combination of the two, and can be used to explore the
area-delay tradeoff.  A value of '2' minimizes the delay on an estimate of the
critical path obtained from a trivial 2-input NAND mapping, and the area
elsewhere.
.PP 
The \fB-n\fP option allows the access to a better tree covering algorithm.  It
can only be used in delay mode, i.e. with an argument of 1: \fB-n 1\fP.  This
algorithm gives better performance than \fB-m 1\fP but is noticeably slower.  It uses a
finer dynamic programming algorithm that takes output load values into account,
while \fB-m 1\fP option supposes all loads to be the same.  As a consequence,
the \fB-n 1\fP option performs better than \fB-m 1\fP especially with rich
libraries of gates. Both algorithms use heuristics to guess the load value at
multiple fanout points.  Both options should always be used with fanout
optimization turned on.
.PP
If \fB-r\fP is given (\fIraw mode\fP), the network must already be either 1-
and 2-input NAND gates, or 1- and 2-input NOR gates form, depending on whether
a NAND-library, or a NOR-library was specified when the library was originally
read (see \fBread_library\fR).
If \fB-r\fP is not given, appropriate commands are
inserted to transform the network into the correct format.
.PP
The \fB-s\fP option prints brief statistics on the mapping results.
.PP
The \fB-p\fP option forces the mapper to ignore the delay information provided
by the user at primary inputs and primary outputs (arrival times, required
times, loads, drive capability). It is intended for experimental use.  This
option forces the arrival times and required times to be all 0, the loads and
drive capabilities to be all equal to the load and drive capability of the second
smallest inverter in the library.  If there is only one inverter, the data are
taken from that inverter.
.PP
The \fB-v n\fP options is for development use, and provides debugging
information of varying degrees of verbosity as the mapping proceeds.
.PP
The \fB-A\fP option recovers area after fanout optimization
at little or no delay cost by resizing buffers and inverters.
.PP
The \fB-B n\fP option controls the enforcement of load limits during fanout
optimization.   A value of 0 ignores the load limits.  A value of 1 takes
load limits into account.   The default is set to 1.
This option is effective only in conjunction with fanout optimization.  It is
implemented by artificially increasing the load at a gate output by a
multiplicative factor whenever the load exceeds the limit specified in the
library. The default multiplicative factor is 1000. This value can be changed
with the \fB-b n\fP option. There is a priori no reason to change this value.
.PP
The \fB-F\fP option performs fanout optimization.  This disables the internal
fanout handling (i.e. forces \fB-f 0\fP).  In order to recover area
after fanout optimization use the \fB-A\fP option. There are several fanout
optimization algorithms implemented in \fBSIS\fR. For details, type
\fBhelp fanout_alg\fR and \fBhelp fanout_params\fR.
.PP
The \fB-G\fP option recovers area after fanout optimization
at no cost in delay by resizing all gates in the network.
.PP
The \fB-W\fP option suppresses the warning messages.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
one_hot
.PP
Does a quick one-hot encoding of the current STG.
It assigns one-hot codes, minimizes the resulting PLA
using espresso, and returns the network to SIS.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
phase [-qgst] [-r n]
.PP
Decide for each node whether to implement the node or its complement
in order to reduce the total cost of the network.  If the network is
mapped, the cost is the total area and the network will be kept mapped,
otherwise, the cost is the total number of inverters in the network
assuming all the inverters are already in the network.
At the end, all the necessary inverters are inserted into the network
and all the extra inverters are removed from the network.
.PP
The default algorithm, which can also be specified by \fB-q\fR option, is 
a greedy algorithm called \fIquick phase\fR.  The \fB-g\fR option uses
the Kernighan-Lin type algorithm called \fIgood phase\fR.  The
\fB-s\fR option chooses the Simulated Annealing algorithm.  The \fB-r n\fR
option chooses a random-greedy algorithm which does a random assignment first,
uses a greedy approach to get to a local minimum, and iterates
\fIn\fR times.  If the \fB-t\fR option is specified, some tracing
information is printed as the assignment proceeds.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
plot_blif [-k] [-r] [-i] [-g WxH+X+Y] [-n name]
.PP
The \fBplot_blif\fR command 
creates a window with an abstract representation of the
network, at its current level of optimization, labeling all nodes, including
primary inputs and outputs.
Vectors are used to show relationships between the various nodes.
Latches are not printed explicitly.
The network is drawn as an acyclic combinational circuit.
Labelled arrows indicate the locations of the latches.
.PP
The \fB-k\fR option "kills" (closes) the most recent plot window with
the current network name.
.PP
The \fB-r\fR option replaces the contents of an existing plot window
with the current network structure.
This is useful if the network has been modified since it was last
plotted.
If no plot window is open with the current network name, the command
has no effect.
.PP
The \fB-i\fR option forces a plot of the internal network structure
used by \fISIS\fP.
The default is to plot the structure corresponding to the write_blif
command.
The primary difference in the internal structure is in how primary
outputs are handled.
.PP
The \fB-g\fR option allows an initial geometry to be specified
for the plot window.
.PP
The \fB-n\fR option allows "name" to be used for the plot window name
instead of the network name.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
power_estimate [-m c] [-d c] [-t c] [-s c] [-a n] [-e f] [-n n]
               [-f file] [-S] [-M n] [-N n] [-R] [-h] [-v]

.PP
Estimates the power dissipated in a circuit due to switching activity:
.nf
        P = 0.5 x Vdd^2 x sum(p x C ) / f
                           i   i   i
where

        Vdd = 5V
        f = 20MHz
        p = expected number of transitions of node i in one clock cycle
         i
        C = capacitive load of node i
         i
.fi

The expected number of transitions of each node per clock cycle is
calculated through symbolic simulation, based on the static
probabilities of the primary inputs (by default prob_one = prob_zero =
0.5). The capacitive load of a node is obtained by summing the gate
capacitances of its fanout nodes and adding some internal drain
capacitance. Gate capacitances are multiple of a minimum sized
transistor (0.01pF), admitting transistor sizing based on the number
of inputs to the node (up to a value max_input_sizing, default
4). Drain capacitances are calculated from the number of transistors
this node has (multiple of 0.005pF) and this number can be obtained
either from a factored form or sum of products.

.PP
\fB-m c\fR Estimation mode, c either SAMPLING or BDD (default).

.PP
\fB-d c\fR Delay model, c one of ZERO (default), UNIT or GENERAL (from
library).

.PP
\fB-t c\fR Estimation type, c one of COMBINATIONAL (default),
SEQUENTIAL, PIPELINE or DYNAMIC (for dynamic domino circuits).

.PP
\fB-s c\fR PS lines probability calculation method, c one of APPROXIMATE
(default), EXACT or UNIFORM (0.5 is used). Only used for SEQUENTIAL
type.

.PP
\fB-a n\fR Number of PS lines to be correlated (default 1). Only used
for the APPROXIMATION method.

.PP
\fB-e f\fR Maximum error allowed for PS lines probabilities (default
0.01). Only used for the APPROXIMATION method.

.PP
\fB-n n\fR Number of sets of 32 input vectors to be simulated (default
100). Only used for SAMPLING mode.

.PP
\fB-f filename\fR Allows the specification of input probabilities, node
capacitances and node delays in the format:

.nf
                name "nodename" p0 "value"
                name "nodename" p1 "value"
                name "nodename" cap_factor "value"
                name "nodename" delay "value"
.fi

.PP
\fB-S\fR Assumes complex gates in sum of products form (default is factored
form).

.PP
\fB-M n\fR Maximum number of inputs of a node considered for transistor
sizing (default 4).

.PP
\fB-N n\fR Interval of input vectors for which the current value of
power estimation is printed. Only used for SAMPLING mode.

.PP
\fB-R\fR Sets latch capacitances to 0, only comb power reported.

.PP
\fB-h\fR Prints power_estimate usage.

.PP
\fB-V n\fR Verbose run time information.

Note: currently a memory fault occurs on the RS6000 when the exact calculation
is used for present state probabilities.  This is probably due to the use
of stg_extract. 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
power_free_info

.PP
Frees data structures storing capacitance and switching of every node in
the network.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
power_print

.PP
Prints the switching probability and capacitance for each node in the
network. Only valid after a power estimation has been performed.


.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print [-n] [-d] node-list
.PP
Print all the nodes in the \fBnode-list\fR in sum-of-product form.
.PP
If \fB-n\fR option is specified, the nodes are printed in
the negative form. (i.e. a' + b' will be printed as (a b)').
.PP
If \fB-d\fR option is specified, the nodes in the external
don't care network are printed.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_altname node-list
.PP
Print the alternate name of all the nodes in the
\fBnode-list\fR.  If the current name mode is \fIshort\fR (\fBSIS\fR
internal name), the alternate name will be the \fIlong\fR name 
(user-specified name) and vice-versa.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_clock
.PP
Prints the clocking scheme associated with the current network.
The clocking scheme printed depends on the current setting
of the clock data structure (see \fB chng_clock\fR).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_delay [-alrs] [-m model] [-p n] [-f file-name] [node-list]
.PP
Do a delay trace (static timing analysis)
on the network depending on the specified \fBmodel\fR
and print the delay data.
Without any arguments the routine will
use the \fIlibrary\fR model which assumes that the network is mapped and
will print the arrival times, required times and the slack for all the
nodes in the network.
.PP
Specifying an optional \fBnode-list\fR will print the delay data
only for the specified nodes.
.PP
The user can selectively have portions of the delay data printed.
The option \fB-a\fP will cause the arrival times to be printed. 
The option \fB-r\fP will cause the required times to be printed. 
The option \fB-s\fP will cause the slacks at nodes to be reported.
The option \fB-l\fP will cause the load driven by the node to be printed.
.PP
The option \fB-p n\fP when specified with one of the options \fB-[alrs]\fP
will print out the delay data so that the first \fBn\fP nodes with the
most critical values are printed. The critical portion of the delay data
is determined by the first of the options \fB-[alrs]\fP specified.
Thus specifying \fB-p n -[al]\fP prints the \fBn\fP nodes with the greatest
arrival-time/load. For the \fB-[rs]\fP option the nodes with the smallest
required-time/slack are printed.
.PP
The delay model can be specified by the \fB-m\fP option followed by one
of the following keywords --- \fIunit\fR, \fIunit-fanout\fR,
\fIlibrary\fR, \fImapped\fR or \fItdc\fR.
Specifying \fIunit\fR results in delay being computed as 1 unit per node in
the network.
\fIunit-fanout\fR adds an additional delay of 0.2 per fanout.
If a library has been read in using the \fBread_library\fP command one
can use more accurate models, \fImapped\fR and \fIlibrary\fR, by using data 
stored in the library. Using the model \fIlibrary\fR assumes  that the network
has been mapped. The \fImapped\fR model does not make this assumption and will
do a mapping of the nodes on an individual basis to compute a
delay model for use during the delay trace.
The \fItdc\fR model is an attempt to predict the delay of a node based on the
distribution of arrival times. The parameters used in this model prediction
are optionally specified using the \fB-f\fR option.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_factor node-list
.PP
Print all the nodes in the \fBnode-list\fR in the \fIfactored\fR form.
If a node has not beed factored, \fIfactor -q\fR will be used to 
factor the node.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_gate [-ps] node-list
.PP
Prints the information provided in the library for the list of mapped
gates.
.PP
The \fB-p\fR option prints the pin information of the gates.
.PP
The \fB-s\fR option prints summary of the gates and their area.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_io [-d] [node-list]
.PP
Print both fanin and fanout list for each node in the \fBnode-list\fR.
Absence of \fBnode-list\fR implies all the nodes in the current network.
.PP
If the \fB-d\fR option is specified, the nodes in the external don't care
network are considered.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_kernel [-as] node-list
.PP
Print kernels and corresponding co-kernels of all the nodes in
the \fBnode-list\fR.  If \fB-a\fR option (default) is specified,
all kernels, including the function itself if it is a kernel, are
printed.  If \fB-s\fR option is specified, only
the sub-kernels are printed.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_latch [-s] [node-list]
.PP
With no arguments, \fBprint_latch\fR prints out information for
all the latches in the network.
The information printed for each latch is the latch input, latch output,
initial value, current value, synchronization type, and controlling node.
The latch values can be 0, 1, 2 (don't care), and 3 (undefined).

If the \fB-s\fR option is specified, only the latch input, output, initial
and current values are given.
If a \fBnode-list\fR is given, only the latches associated with those
nodes are printed (each node should be a latch input or output).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_level [-l] [-c] [-m model] [-t value] [node-list]
.PP
Prints the nodes of the network according to their level. 
When called with a \fBnode-list\fR, only the nodes in the
transitve fanin of the specified nodes are printed.
The primary inputs are assigned level 0, and the level of
a node is the length of the longest path from it to a
primary input. The \fB -l\fR options prints only the 
number of levels in the network.
.PP
If the \fB-c\fR option is specified, only critical nodes are
printed according to their level. The delay trace is done
according to the \fB-m model\fR option (default is the 
unit-fanout model) and all the nodes with a slack within a
\fB-t value\fR of the smallest slack are considered to be
critical.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_library [-a][-f][-h][-l][-r] [function-string]
.PP
Print the contents of the current library.  If the optional string is
given, only the combinational gates with the same logic function as the string
will be printed.  \fIfunction-string\fP is in the format of
read_eqn.  For example
.in +1i
.nf
print_library "f=!(a*b);" 
.in -1i
.fi
will print all combinational gates with a NAND2 logic function.
.PP
The \fB-a\fP option prints asynchronous type latches matching the 'function-string'.
.PP
The \fB-f\fP option prints falling edge triggered flip-flops matching the 'function-string'.
.PP
The \fB-h\fP option prints active high transparent latches matching the 'function-string'.
.PP
The \fB-l\fP option prints active low transparent latches matching the 'function-string'.
.PP
The \fB-r\fP option prints rising edge triggered flip-flops matching the 'function-string'.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_map_stats
.PP
Prints delay and area information of the network. The network should be mapped. 
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_state 
.PP
Prints out the current state of the machine for both the STG
and the logic implementation.
For the logic implementation, the current state is printed as
a string of integers representing the values on the latches:
0, 1, 2 (don't care), and 3 (undefined).
For the STG, the current state is printed with its symbolic
and encoded names.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_stats [-f] [-d]
.PP
Print the current network status, which includes the network name,
number of primary inputs (pi), number of primary outputs (po),
number of nodes (nodes), the number of latches (latches),
the number of literals in the sum-of-product
form (lits(sop)), and the number of states in the STG
(#states(STG)).
.PP
If \fB-f\fR option is specified, the number of literals in
the factored form (lits(fac)) is computed.
This could be slow when 
the factored form for some network takes too long to generate. 
.PP
If \fB-d\fR option is specified, the statistics of the external don't care
network is printed.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
print_value [-a] [-d] [-p n] node-list
.PP
Print the value of all the nodes in the \fBnode-list\fR.  The value
is currently defined as the number of literals increased if the node
were eliminated from the network.  Since the value of a node depends
on the particular factored form of the node and its fanouts, all the
nodes which don't have factored forms will be factored using
\fIfactor -q\fR.
.PP
The \fB-a\fR option prints the values in ascending order.
.PP
The \fB-d\fR option prints the values in descending order.
.PP
The \fB-p\fR takes an argument \fBn\fR, and directs print_value to only
print the top n values.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
quit [-s]
.PP
Stop the program.  Does not save the current network before exiting.
\fB-s\fP frees all the memory before quitting.  This is slower, and
is used for finding core leaks or when \fIsis\fR is called from
another program.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_astg [<file-name>]
.PP
Read a text description of an Asynchronous Signal Transition Graph (ASTG).
The overall format follows the style of BLIF, and uses
an adjacency list to describe the net interconnection
structure.
If no filename is specified, the description is read from stdin.
.PP
All names in the ASTG description must start with a letter,
consist of letters, digits and underscores, and are case-sensitive.
A signal transition is represented with a suffix: "+" means a low
to high transition, "-" means high to low, "~" means toggles (changes
to the opposite value.
.PP
 .model <model-name>
.br
This gives an arbitrary name to the ASTG, and it
must be the first line of the model description.
.PP
 .inputs <signal-list>
.br
Specifies a list of names of ASTG input signals.
Signals from multiple .inputs are concatenated.
.PP
 .outputs <signal-list>
.br
Specifies a list of names of ASTG output signals.
Signals from multiple .inputs are concatenated.
.PP
 .internal <signal-list>
.br
Specifies a list of names of ASTG internal signals, i.e.
signals which are only used to maintain state information.
.PP
 .dummy <name-list>
.br
Specifies a list of names which are accepted as dummy or null
transitions.
Null transitions are necessary to specify some behaviors using
the ASTG syntax.
By convention, the name "e" is used as a dummy signal (to
represent epsilon transitions).
 .graph
.br
Indicates the lines which follow describe the ASTG net structure
using an adjacency list format.
This must follow all signal declarations (.inputs, etc.).
Net places are optional for simple constraints between two transitions;
in this case an intervening place is generated automatically.
Multiple instances of a transition are distinguished by following
them with a slash and a copy number.
For example, a second instance of transition "t+" can be
specified by "t+/2".
Copy numbers do not have to be consecutive.
.PP
 .marking {<place-list>}
An initial marking can optionally be specified after the net structure
has been given.
Implied places (see .graph) between two transitions x* and y* can
be specified using the syntax <x*,y*>.
 .end
This required line indicates the end of the ASTG description.
.PP
Error messages are printed for any unrecognized input sequences.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_blif [-a] filename
.PP
Read in a network from the file \fBfilename\fP which is assumed
to be in \fIblif\fP format.
The network name is given
by the \fI.model\fP statement in the file.  If a \fI.model\fP
is not given, the network name is the filename with any trailing
extension removed.
See the blif.tex document for a complete description
of the \fIblif\fP format.
.PP
The user can also specify an external don't care network. This
network must be placed after the care network in the same
file. The statement \fI.exdc\fP must precede the description
of the external don't care network. The names of primary outputs and
primary inputs of the external don't care network
must be exactly the same as the names of primary outputs
and primary inputs of the care network.
.PP
Usual filename conventions apply: \fB-\fP (or no
filename) stands for standard input, and tilde-expansion is performed
on the filename.
.PP
Normal operation is to replace the current network with a new network.
If no external don't care network is specified, the external don't
care network is set to NIL (nonexistent). Otherwise the external
don't care network is replaced by the new external don't care network.
The -a option specifies that the new network should be appended to the
current network.  Functions are associated between the two networks
using the long names of each network.  Name conflicts (where two
functions attempt to define the same name) generate warning messages
and are resolved by renaming the signal from the new network.
.PP
The \fB-s\fR option, though accepted, has no effect on \fBread_blif\fR, and is 
instead reserved for the \fBread_pla\fR command.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_eqn [-a] [filename]
.PP
Read a set of logic equations in the format expected by eqntott(1).
Each equation becomes a node in the logic network.
.PP
INORDER and OUTORDER can be used to specify the primary inputs and
primary outputs for the network.  If neither is given, then primary
inputs are inferred from signals which are not driven, and
primary outputs are inferred from signals which do not have any
fanout.
.PP
The equations are of the form "<signal> = <expr> ;".
For reference, the equation format uses the operators:
.LP
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 80 0
.nr 38 \w()
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w!= (or ^)
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w==
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w! 
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w& (or *)
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \w| (or +)
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 81 0
.nr 38 \wgrouping
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wexclusive-or 
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wexclusive-nor
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wcomplement
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wboolean-and
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \wboolean-or
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(1*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.nr TW +1*\n(38
.if t .if \n(TW>\n(.li .tm Table at line 3047 file Input is too wide - \n(TW units
.ne 6v+0p
.nr #I \n(.i
.in +(\n(.lu-\n(TWu-\n(.iu)/2u
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(33\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 36 \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(33\l'|\n(TWu\(ul'\s0
.vs \n(36u
.mk #a
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'()\h'|\n(41u'grouping
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'!= (or ^)\h'|\n(41u'exclusive-or 
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'==\h'|\n(41u'exclusive-nor
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'! \h'|\n(41u'complement
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'& (or *)\h'|\n(41u'boolean-and
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'| (or +)\h'|\n(41u'boolean-or
.fc
.nr T. 1
.T# 1
.in \n(#Iu
.35
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-9
As a simple extension to eqntott, juxtaposition of two operands stands
for boolean-and, and ' used as a post-fix operator stands for complement.
Hence, 
.nf
	F = a*!b + c*!d ;
.fi
and
.nf
	F = a b' + c d' ;
.fi
represent the same equation.
.PP
Note that eqntott and \fBread_eqn\fR treat the intermediate nodes of a network
slightly differently.
\fBread_eqn\fR will not make an intermediate node
a primary output unless it also appears in the OUTORDER list.
Also, the resulting network is a multiple-level network with all
of the intermediate signals preserved.
Finally, eqntott is order-dependent in that it requires signals to
be defined before they can be used again; \fBread_eqn\fR relaxes this
condition.
.PP
The \fB-a\fR option specifies that the new network should be appended to the
current network.  Functions are associated between the two networks
using the long names of each network.  Name conflicts (where two
functions attempt to define the same name) generate warning messages
and are resolved by renaming the signal from the new network.
.PP
The \fB-s\fR option, though accepted, has no effect on \fBread_eqn\fR
and is instead
reserved for the \fBread_pla\fR command.
.pp
Note that since the characters '(' and ')' are used for grouping,
they cannot be part of a signal name.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_kiss [filename]
.PP
Reads a \fIkiss2\fP format file into a state transition graph.  The state
names may be symbolic or strings of "0" and "1".  Inputs and outputs should be
strings of "0", "1", and "-"; inputs should not be symbolic.
The \fIkiss2\fP format is described in doc/blif.tex.
Note that there is no mechanism for specifying the names of the
I/O pins in \fIkiss2\fP.
Naming can be done in \fBSIS\fP by specifying a \fIblif\fP
file containing the \fI.inputs\fP and \fI.outputs\fP lines
(which give I/O names) followed by the embedded \fIkiss2\fP
file.
See also \fBstg_to_network\fR, \fBread_kiss_net\fR.
.PP
Note that \fIread_kiss\fP followed by \fIwrite_kiss\fP alters the ordering of
the product terms.  This could make a difference in the \fInova\fP
output.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_library [-ainr] filename
.PP
Read a \fBSIS\fR-format library for future technology mapping.
The \fB-a\fP option appends the library to the current library;
otherwise, any previous library is discarded.
The \fB-i\fP flag suppresses adding extra inverters to all of the
primitives.  This is intended for debugging only.
The \fB-n\fP flag requests that a library, if it is generated, be
made using NAND gates rather than NOR gates.
The \fB-r\fP flag reads a raw library format (given in BLIF)
rather than the normal genlib format.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_oct cell[:view]
.PP
Read in a network from the Oct facet `cell:view:contents'.
If `view' is not specified, it defaults to `logic'.
The network name is set to `cell:view'.
Oct nets without names are given machine-generated unique names.
All primary inputs and outputs are named the same as the equivalent
Oct formal terminals of the facet.
.PP
This operation replaces the current network with the new network.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_pla [-a] [-s] [-c] filename
.PP
Read in an espresso-format PLA from the
file \fBfilename\fP (see espresso(5) for more
information).  The network name is derived
from the filename with any trailing extension removed.
.PP
Usual filename conventions apply: \fB-\fP (or no
filename) stands for standard input, and tilde-expansion is performed
on the filename.
.PP
Normal operation is to replace the current network with a single-level
network of complex gates with the same logic functions as the PLA outputs.
This makes each PLA output a separate single-output function and is
a good starting point for the standard scripts.
If don't care conditions exist, the external
don't care network is also replaced with a single-level network
which implements the don't care conditions of the PLA.
Otherwise, the external don't care network is set to NIL (nonexistent).
.PP
The \fB-c\fP option replaces the current network with 
a two-level network of NOR-gates (and inverters)
which implements the PLA.
This preserves the multiple-output nature of the PLA.
The external don't care network is manipulated exactly the same as above.
This used to be the default, while the \fB-s\fP option
replaced the network with a single-level network as described above.
The \fB-s\fP option has been retained for compatibility.
.PP
The \fB-a\fR option specifies that the new network should be appended to the
current network.
Functions are associated between the two networks
using the long names of each network.
Name conflicts (two
functions attempt to define the same name) generate warning messages
and are resolved by renaming the signal from the new network.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
read_slif filename
.PP
Read in a network from the file \fBfilename\fP which is in \fIslif\fP
format.  \fISLIF\fP is a hierarchical circuit description language and the
root network, the one returned to the caller, is defined to be the first
network encountered in the file \fBfilename\fP.

.XX
red_removal [-hqrRpt] [-d RTG_depth] [-n n_fault_sim] [-v verbosity_level] 
            [-y random_prop_depth]
.PP
Perform sequential redundancy removal using random test generation,
deterministic test generation, and fault simulation. Deterministic test 
generation is accomplished by one of two methods. The first method is a 
three-step test generation algorithm consisting of combinational test 
generation (assuming that latch outputs are controllable, and that latch 
inputs are observable), followed by state justification and propagation, 
when necessary. The combinational test generation is accomplished using 
Boolean satisfiability. Justification and propagation are performed using 
implicit state transition graph traversal techniques. If the three-step 
method does not generate a test for a fault, then the product of the good 
and faulty circuit is built and traversed, as in sequential circuit 
verification. If this traversal proves the circuits equivalent, then the 
fault is redundant; otherwise any differentiating sequence is a test for 
the fault.
.PP
Each time a redundant fault is encountered during deterministic test
generation, the redundant line is replaced by a constant 1 or 0, and
deterministic test generation begins again. At the end of the redundancy
removal procedure, the network is 100% testable for single stuck faults 
unless the test generator aborts on some faults.
.PP
For combinational circuits, external don't cares are automatically taken 
into account when the don't care network is attached to the care network. The PI's and PO's of the external don't care network (when it is not NIL) must match exactly with the care network. That is, the don't care network cannot specify only a subset of the PI's or PO's of the care network. If this
condition is not met, then the atpg package automatically adds dummy primary
inputs and outputs to the external don't care network.
.PP
The \fB-h\fP option restricts the boolean satisfiability algorithm to not 
use non-local implications. Four greedy ordering heuristics are tried in 
this case instead of the default of eight. Hard-to-test faults that can only 
be tested with non-local implication information are aborted by this option.
.PP
The \fB-q\fP specifies "quick redundancy removal." With this option, the 
deterministic test generation algorithm identifies only those redundant faults
that cannot be excited from any reachable state. In practice, quick redundancy 
removal usually gives the same results as regular redundancy removal, in much 
less time.  
.PP
The \fB-r\fP option causes the test generator not to perform random test pattern
generation.
.PP
The \fB-R\fP option causes the test generator not to perform random propagation. 
(Deterministic propagation is still attempted).  
.PP
The \fB-p\fP option causes the test generator not to build any product 
machines. Thus, neither deterministic propagation nor good/faulty product 
machine traversal will be performed. 
.PP
The \fB-t\fP option first converts the network to arbitrary fanin AND and
OR gates. The decomposed network is returned.
.PP
The \fB-d\fP option allows the specification of the length of the random
sequences applied during random test generation. The default length is
the depth of the circuit's state transition graph. 
.PP
The \fB-n\fP option allows the specification of the number of sequences
to fault simulate at one time during fault simulation. The default is the
system word length.  
.PP
The \fB-v\fP allows the specification of the verbosity level of the output.
.PP
The \fB-y\fP option allows the specification of the length of the random
sequences applied during random propagation. The default length is 20. 
.PP
Note: in order to use this command with sequential circuits, the circuit
reset state must be specified in the circuit input file.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
reduce_depth [-b] [-d #] [-g] [-r] [-s #] [-v #] [-R #.#] [-S #] [-f #]
.PP
This command is to be used to improve the speed of a network before
technology mapping.  It performs a partial collapse of the network by
first clustering nodes according to some criteria and collapsing each
cluster into a single node. The clusters are formed as follows:  a
maximum cluster size is first computed, and the algorithm finds a
clustering that respects this size limit and minimizes the number of
levels in the network after the collapsing of the clusters. The size
limit is a limit on the number of nodes covered by the cluster, and
does not take into account the complexity of the nodes. Therefore this
command should only be used on networks decomposed into simple gates.
The cluster size limit can be provided in a variety of ways, 
depending on which option is used.
.PP
The \fB-b\fP option performs the clustering under the duplication ratio 
constraint specified by \fB-R\fP option.
.PP
The \fB-d #\fP option specifies the desired depth of the network after
clustering. The depth counts the number of nodes. Since each node
is expressed as a sum-of-products, specifying depth of 1 corresponds
to collapsing the network to two levels of logic. The algorithm
computes the minimum cluster size limit that yields a depth of \fBn\fR.
.PP 
The \fB-g\fP option prints out statistics based on cluster sizes.  No
clustering is done.
.PP
The \fB-r\fP option specifies a modification of the clustering
algorithm that produces the same number of logic levels but with less
duplication of logic.
.PP
The \fB-s #\fP option specifies the desired cluster size limit.
.PP
The \fB-v #\fP option specifies a verbosity level. It is used mainly for
debugging. 
.PP
The \fB-R #.#\fP option specifies the maximum duplication ratio.  The default is 2.0.
.PP
The \fB-S #\fP option specifies the smallest cluster size limit that
produces the same depth as a cluster size limit of \fBn\fR.
.PP
The \fB-f #\fP option specifies a cluster size limit in terms
of the number of fanins of the cluster. Its intended use is
for table-lookup FPGAs. It is a poor man's version of FlowMap.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
remove_dep [-o] [-v n] input output-list
.PP
The first node passed as argument should be an external primary input.
The remaining nodes passed as arguments should be external primary outputs.
This command assumes that the dependency between the given input
and the given outputs is structural but not logical, and it removes
these structural dependencies by forcing the input at 0 in the cone
of logic going from the input to the listed outputs.
.PP    
The logic that depends on the given input and is shared with outputs
not passed as arguments is duplicated.
.PP
This function is useful when performing hierarchical optimization,
to guarantee that sis does not introduce dependencies that will create
combinational logic loops when the hierarchy is reassembled.
.PP
\fB-v\fR allows the specification of the verbosity level of the output.
The default value is 0.
.PP
With option \fB-o\fR the constant 1 is used instead of the constant 0
to replace the input.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
remove_latches [-v n] [-f n] [-r] [-b]
.PP
This command removes redundant latches, using three different techniques.
.PP
First, it performs some local retiming, by moving forward latches
across combinational logic if that decreases the latch count. This
optimization can be disabled by specifying the option \fB-r\fR.
.PP
Second, it looks for boot latches, that is latches fed by a constant
but initialized at the opposite value. If there are such latches, it
looks for a state equivalent to the initial state in which the initial
value of the latch is equal to the value of its constant input. When
this optimization applies, the latch can be removed, and constant
folding propagates the constant across the logic. This optimization
can be disabled by specifying the option \fB-b\fR.
.PP
Third, it computes the set of reachable states, and checks whether
some latches cannot be deduced combinationally from other latches.
If that is the case, and if the fanin limit specified by the \fB-f\fR
option is not exceeded, the latch is removed and replaced by
combinational logic.
.PP
\fB-v\fR allows the specification of the verbosity level of the output.
The default value is 0.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
replace [-t n] [-v n]
.PP
This is a simple routine that performs the same function as
\fBresub -a -d\fR on a network decomposed in 2-input NAND gates
using \fBtech_decomp -o 2\fR. It is just much faster.
.PP
The \fB-v n\fP specifies the verbosity level.
It is only used for debugging.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
reset_name [-ls]
.PP
Resets either the short names (starting again from the single letter a)
with the \fB-l\fP option, or the \fBSIS\fR-generated 
long-names (starting again from [0]) with the \fB-s\fP option.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
resub [-a] [-b] [-d] [node-list]
.PP
Resubstitute each node in the \fBnode-list\fR into all the nodes in the network.
The resubstitution will try to use both the \fIpositive\fR and \fInegative\fR
phase of the node.  If \fBnode-list\fR is not specified, the resubstitution
will be done for every node in the network and this operation will keep
looping until no more changes of the network can be made.  Note
the difference between \fBresub *\fR and \fBresub\fR.  The
former will apply the resubstitution to each node only once.
.PP
The \fB-a\fR (default) option uses algebraic division when
substituting one node into another.
The division is
performed on both the divisor and its complement.
.PP
The \fB-b\fR option uses Boolean division when substituting one
node into another.
NOTE: Boolean resubstitution has not yet been implemented.
.PP
The \fB-d\fR option directs \fBresub\fR not to use the complement of a given
node in algebraic resubstitutions.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
retime [-nfim] [-c #.#] [-t #.#] [-d #.#] [-a #.#] [-v #]
.PP
Applies the retiming transformation on the circuit in an
effort to reduce the cycle time. The retiming operation is 
supported only for single phase, edge-triggered designs. Both
mapped and unmapped networks can be retimed.
The algorithm attempts to maintain the initial state information.
.PP
The algorithm expects to work on mapped networks so that accurate
delays on the gates can be used.
However, an unmapped network can be retimed by using
the \fB-n\fR option.
In that case the delay through 
each node is computed according to the \fIunit-fanout\fR delay model.
\fIThe user should be aware of the fact that when retiming circuits
containing complex registers (JK, D-flip flops with enables/presets),
the complex registers may have to be decomposed into simpler gates.\fR
.PP
By default the algorithm uses a relaxation based approach which
is very fast. An alternate formulation uses a mathematical 
programming formulation and can be selected using the \fB-f\fR option.
After profiling on a number of circuits only one will be retained.
.PP
The \fB-m\fR option can be used to minimize the number of registers
under cycle time constraints. If the cycle time is not specified 
using the \fB-c\fR option then this command will try to minimize the
cycle time. Thus to obtain the absolute minimum number of registers
for a circuit the user should specify a very loose cycle time constraint
(very large value for the \fB-c\fR option).
.PP
The retiming algorithm will try to compute the new initial states
of the latches.
In case no feasible initial state exists the retiming is aborted and
the network is not modified. To suppress the initialization routine
use the \fB-i\fR option. In that case the initial values for all the
latches after retiming is set to value of 2 (DONT_CARE).
.PP
The desired clock period can be specified with the \fB-c value\fR 
option. When this option is not used the algorithm first checks to see
if there is a cycle_time specification with the current network (the
value depends on the current setting of the clock_flag in the network)
and tries to meet this. If no cycle_time is specified with the design
the retiming operation tries to minimize the cycle time. For this it 
uses a binary search for testing feasible clock values. The tolerance of
the binary search can be specified with the \fB-t value\fR option (the
default is 0.1).
.PP
Latches in the network can be assigned a propogation delay and an
area. These are helpful in the realistic modelling of the circuit
delay and area. Use the \fB-d value\fR option to specify the delay
through a latch (to approximate the setup and propogation delay of
the latch) and the \fB-a value\fR option to specify the area
of a latch. In case of mapped networks, these values are automatically
determined from the library of gates.
.PP
The \fB-v value\fR selects the verbosity level. The range is 1-100
(100 will literally swamp you with a lot of unneeded data). Use 
the value 1 to see the progress of the algorithm.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
save filename
.PP
Save a copy of the current executable to a file which can be restarted.
This can be used to freeze the current network or the current library
for later optimization.  When the executable \fBfilename\fR is executed,
execution returns to the top-level of the command interpreter.
.PP
NOTE: The \fBsave\fR command is very operating-system dependent and may not
be implemented on your system.
If this is the case then the \fBsave\fR
command is unusable on your system.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
set [name] [value]
.X1
unset name ...
.PP
A variable environment is maintained by the command interpreter.
The \fBset\fR command sets a variable to a particular value, and the
\fBunset\fR command removes the definition of a variable.
If \fBset\fR is given no arguments, it prints the definition of all variables.
.PP
Different commands use environment information for different purposes.
The command interpreter makes use of the following:
.TP 8
.B autoexec
Defines a command string to be automatically executed after every command
processed by the command interpreter.
This is useful for things like timing
commands, or tracing the progress of optimization.
.TP 8
.B sisout
Standard output (normally stdout) can be re-directed to a file
by setting the variable sisout.
.TP 8
.B siserr
Standard error (normally stderr) can be re-directed to a file
by setting the variable siserr.
.TP 8
.B history
Each valid command entered at the prompt can be echoed to a file
by setting the variable history.
.TP 8
.B history_char
By default the character `%' is used to do the history substitution
inside sis. This can be changed by setting the variable \fBhistory_char\fR.
.TP 8
.B shell_char
By default the character `!' is used to do invoke shell commands from
inside sis.  This can be changed by setting the variable \fBshell_char\fR.
\fI In order to switch the interpretation of shell_char and history_char it is
neccessary to first set history_char and then the shell_char. Alternately,
you may escape the current history char by preceeding it with
a `\' while setting the shell_char. In addition none of them can be set 
to a `#' which is reserved for comments.\fR
.TP 8
.B filec
Setting this variable enables the user to use "file-completion" like in 
the C-shell. An ESC causes the current line to be extended to its unique 
completion. A CTRL-d generates a list of the possible extensions.
.TP 8
.B open_path
\fBopen_path\fR (in analogy to the shell-variable PATH) is a list of
colon-separated strings giving directories to be searched whenever
a file is opened for read.  Typically the current directory (.) is
first in this list.  The standard system 
library (typically $SIS/sis_lib) is always implicitly appended 
to the current path.
This provides a convenient short-hand
mechanism for reaching standard library files.
.TP 8
.B prompt
defines the prompt string. If the prompt string contains a `%'(or whatever
the history_char has been set to using the set command), the `%'
will be replaced whenever the prompt is printed by the current event number.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
set_delay  [-a|d|i|l|r f]  [-A f] [-D f] [-I f] [-L f] [-R f] [-S f] [-W f][o1 o2 ... | i1 i2 ...]
.PP
Set various delay parameters for the inputs and outputs of a network.  
These timing constraints are used by the \fBprint_delay\fP command in
addition to commands like \fBspeed_up\fR, \fBbuffer_opt\fR, and \fBmap\fR
that perform
delay optimizations. The values for these constraints are numbers and it
is the user's responsibility to ensure that these values are meaningful
when a particular delay model is used during the optimizations.
Capitalized options set defaults, lower-case options set the
parameters for the nodes in nodelist, which is either a list of output
nodes or a list of input nodes.
.PP
The option \fB-A\fP sets the default arrival time for primary inputs
to the real value \fBf\fR.
The option \fB-R\fP sets the default required time for primary
outputs to \fBf\fR.
The \fB-D\fP option sets the default drive on a primary
input to \fBf\fR, and the \fB-L\fP option sets the default load on primary
outputs to \fBf\fR.
The \fB-I\fR option specifies the default value for the
maximum load that can be present at a primary input. The \fB-S\fP option
sets the wire load per fanout to \fBf\fR.
The wire loads for a given number of fanouts can be specified
with the \fB-W\fP option. With the \fIi\fPth use 
of the \fB-W\fP option, the load for a gate driving \fIi\fP outputs is set
to the value \fBf\fR.
.PP
The settings can be undone by using a negative number for the value.
This will result in the parameter to be "unspecified" and the
individual commands will use appropriate defaults if neccessary.
.PP
The \fB-a, -r, -d, -i\fP, and \fB-l\fR options can be used to specify the
delay constraints on specific nodes (as opposed to the uppercase options
which specify a default value for ALL terminals). These terminal-specific
values will supersede the defaults specified with the uppercase options.
The \fB-a (-r)\fP option sets the arrival (required) time to \fBf\fR for the 
specified nodes if the node list
given is a list of primary inputs (outputs).
The \fB-d (-i)\fP option sets the drive (maximum load limit) for each node in
the list to \fBf\fR;
if there is a non-primary input in the list this is an error.
The \fB-l\fP  option sets the load on each node in the list to \fBf\fR; if there
is a non-primary output in the list this is an error.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
set_state [-s] [-i] [name]
.PP
Sets the current state in the machine to the given state.
If no
state is given, it sets the current state to the initial state (resets
the machine).
If the \fB-s\fR option is given, only the state of the
STG is changed; if the \fB-i\fR option is specified, only the state of the
logic implementation is changed.  If no logic implementation exists,
or if only the state of the STG is to be changed, then the state name
should be symbolic; otherwise it should be the encoded name of the state.
.XX
short_tests [-fFhirtV] [-v verbosity_level] file
.PP
Perform test generation for sequential circuits with the goal of 
producing small test sets. Random test generation is not used unless
its use is specified by the user. Deterministic test generation is 
accomplished by one of two methods. The first method is a three-step test
generation algorithm consisting of combinational test generation (assuming 
that latch outputs are controllable, and that latch inputs are observable),
followed by state justification and propagation, when necessary. The 
combinational test generation is accomplished using Boolean satisfiability.
Justification and propagation are performed using implicit state transition 
graph traversal techniques. If the three-step method does not generate a 
test for a fault, then the product of the good and faulty circuit is built 
and traversed, as in sequential circuit verification. If this traversal 
proves the circuits equivalent, then the fault is redundant; otherwise any
differentiating sequence is a test for the fault. Fault simulation is
performed after each deterministic test generation. 
.PP
Fault collapsing is performed before test generation, across only simple 
gates. Both fault equivalence and fault dominance are used to reduce the 
fault list.
.PP
Deterministically-generated tests may start from the circuit reset state 
or a state reached by the application of another test. In the latter case,
the new test is appended onto the end of the old test. 
.PP
Reverse fault simulation is performed as a post-processing step to reduce
test set size.
.PP
The \fB-f\fP option causes the test generator not to perform fault simulation 
of deterministically-generated tests on untested faults. 
.PP
The \fB-F\fP option causes the test generator not to use reverse fault 
simulation. 
.PP
The \fB-h\fP option restricts the boolean satisfiability algorithm to not use 
non-local implications. Four greedy ordering heuristics are tried in this case 
instead of the default of eight. Hard-to-test faults that can only be tested 
with non-local implication information are aborted by this option.
.PP
The \fB-i\fP option causes the test generator not to append new tests onto
the end of old tests. 
.PP
The \fB-r\fP option causes the test generator to perform random test pattern
generation and random propagation.
.PP
The \fB-t\fP option first converts the network to arbitrary fanin AND and
OR gates. The decomposed network is returned.
.PP
The \fB-v\fP allows the specification of the verbosity level of the output.
.PP
The \fB-V\fP causes the test generator to not use the three-step algorithm
to generate tests. Instead, only good/faulty product machine verification
is used to generate tests, thus guaranteeing that each individual test 
generated is the shortest possible. 
.PP
If \fBfile\fP is specified, test patterns are written out to the given file.
.PP
Note: in order to use this command with sequential circuits, the circuit
reset state must be specified in the circuit input file.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
sim_verify [-n # pats] filename.blif
.PP
Verify that two networks are equivalent using random-pattern
simulation.  That is, generate a random input vector, simulate the
logic network, and check that the outputs between the two networks
agree.  The first network is the current network, and a second
network is read from the file \fBfilename.blif\fR:
it must be a \fIblif\fR format file.
(This restriction will be fixed when the command interpreter is
expanded to handle multiple networks.)
.PP
\fB-n\fP gives the number of random patterns to simulate.
.PP
NOTE: this command only works for combinational networks.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
simplify [-d][-i <num>[:<num>]] [-m method] [-f filter] [node-list]
.PP
Simplify each node in the \fBnode-list\fR using
\fImethod\fR with the don't-care set generated according to
\fIdctype\fR.
.PP
\fImethod\fR specifies the algorithm used to minimize the nodes.
\fIsnocomp\fR (default) invokes a single pass minimization procedure that does
not compute the complete offset.
\fInocomp\fR invokes the full minimization procedure (ala ESPRESSO) but does
not compute the complete offset.
\fIdcsimp\fR invokes single pass tautology-based minimizer.
.PP
\fIdctype\fR specifies how the don't-care set is generated.
The default don't care set generated is a subset of the fanin don't care set.
\fB-d\fR option specifies that no don't care set is used.
\fB-i m:n\fR specifies that the fanin don't cares of nodes within 
\fBm\fR levels of transitive fanin and \fBn\fR levels of transitive fanout 
of these transitive fanin are to be generated.
.PP
\fIfilter\fR specifies how the don't-care set is filtered.
\fIexact\fR (default) uses the exact filter.
\fIdisj_sup\fR uses the disjoint support filter.
.PP
Note that a node function is replaced with the simplified version
if the new function has fewer literals in factored form.
In the case of a tie, the node function is replaced if the new function
has fewer literals in sum-of-products form.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
simulate in1 in2 in3 ...
.PP
For the current implementation of the network, given a value ('0' or '1')
for each of the primary inputs of the network, simulate prints the value
produced at each of the primary outputs.  The correspondence of the
input values and the primary inputs can be determined by the order in
which the primary inputs and outputs are printed using the \fBwrite_eqn\fR
command.
.PP
For example, for a three-input AND gate, the command

\fB	simulate 1 1 0\fR

will produce a 

	0
.PP
NOTE:  For sequential circuits, this command essentially assumes that all
latches are clocked simultaneously by a single clock.
Simulation will take the current values on the latches (which can be
displayed by using \fBprint_latch\fR) and the user-supplied primary
input values
and simulate the network, placing the new latch values in the
current state of the latches.
The values of the outputs and the new state are printed.
If a more sophisticated simulation method is needed, timing simulation
should be used; this is not currently implemented in SIS.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
source [-psx] filename
.PP
Read commands from a file.  The \fB-p\fP option prints a prompt before
reading each command, and the \fB-x\fP option echoes each command before
it is executed.  The \fB-s\fP option silently ignores an attempt to execute
commands from a nonexistent file.
.PP
Arguments on the command line after the filename are remembered but not
evaluated.  Commands in the script file can then refer to these arguments
using the history substitution mechanism.
.PP
EXAMPLE:
.IP
Contents of test.scr:
.IP
.nf
    read_blif %:2
    collapse
    write_eqn %:2.eqn
.fi
.IP
Typing "source test.scr lion.blif" on the command line will execute the
sequence
.IP
.nf
    read_blif lion.blif
    collapse
    write_eqn lion.blif.eqn
.fi
.IP
If you type "alias st source test.scr" and then type "st lion.blif bozo", you
will execute
.IP
.nf
    read_blif bozo
    collapse
    write_eqn bozo.eqn
.fi
.IP
because "bozo" was the second argument on the last command line typed.  In
other words, command substitution in a script file depends on how the script
file was invoked.
.PP
Some standard script files are provided.  \fIscript\fR (executed by typing
\fBsource script\fP is a script that works well on most examples.
\fIscript.boolean\fR uses a larger part of the don't care set during two-level
minimization, requiring more time and producing better results.
\fIscript.algebraic\fR uses a smaller part of the don't care set.
\fIscript.rugged\fR uses the newest BDD-based techniques,
and \fIscript.delay\fR synthesizes a circuit for a final
implementation that is optimal with respect to speed.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
speed_up [-m model] [-d #] [-w #] [-t #.#] [-i] [-c] [-T] [-a #] [-vD] node-list
.PP
Speed-up the nodes in the \fBnode-list\fR. If no nodes are
specified, it selects the nodes to be speeded-up in order to
speed-up the entire network. The best decomposition seen
so far is accepted (except with the \fB-c\fR flag).  The network
after running speed_up is composed of 2-input AND gates and inverters.
.PP
The \fB-m model\fR option selects the delay model according to
which the delay data is computed. The values allowed for
\fBmodel\fR are \fIunit\fR, \fIunit-fanout\fR and \fImapped\fR.
The \fIunit\fR
delay model counts the level of the circuit as its delay.
The \fIunit-fanout\fR model is intended to capture
a technology-independent model and it assigns a delay of 1 unit to each
gate and 0.2 units to each fanout stem. The \fImapped\fR delay
model uses the delay data in the library to compute delay.
.PP
The \fB-d #\fR option selects the distance up to which the 
critical fanins are collapsed in order to do the speed-up.
A fast value is 3, a good one is 6.
.PP
The \fB-t #.#\fR option determines which nodes are considered 
critical. The critical nodes are those with a slack within
#.# of the most negative slack.
.PP
The \fB-w #\fR option selects between the area mode and the 
pure timing mode.  A value of 0 selects pure-timing mode 
while a value of 1 will conserve as much area as possible.
.PP
The \fB-i\fR option specifies that only the initial 2-input 
NAND decomposition be carried out.
.PP
The \fB-c\fR option specifies that one pass be carried out.
The new decomposition is always accepted, even if it results
in a slower circuit.
.PP
The \fB-T\fR option displays the delay as the iterations progress.
.PP
The \fB-a #\fR option tries to do the specified number of attempts
when restructuring a node. By default the algorithm tries only
one attempt at the restructuring. This option is for experimental
use at this stage.
.PP
The \fB-v\fR and \fB-D\fR options display debugging information.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: 
.\"  * $Author: 
.\"  * $Revision: 
.\"  * $Date: 
.\"  *
.\"
.XX
speedup_alg [-v] alg_list
.PP
Activates selectively one or more performance enhancing algorithms. For a
list of local optimizations known to the system, use the \fB-v\fR option.
The algorithms activated are the ones specified in the list.
For mapped circuits the algorithms perform the optimization and remap
the sub-network that was optimized. \fInoalg\fR performs no
optimization, it only remaps the region. \fIfanout\fR builds a
fanout-tree while \fIrepower\fR simply uses a gate of greater drive
Of the others \fIdivisor\fR and \fI2c_kernel\fR
perform restructuring by extracting kernels and 2-cube divisors. When
applied to the complement of the function these are called
\fIcomp_div\fR and \fIcomp_2c\fR respectively. Techniques based on the
existing structure are \fIcofactor\fR which performs
timing-driven-cofactoring and \fIbypass\fR applies the
generalized-bypass transformation.
.PP
Performance optimization itself is performed using the \fBspeed_up\fR
command without the \fB-f\fR option.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
state_assign progname options
.PP
Perform state assignment on the current STG.
The program used for state assignment is \fBprogname\fP
and it is given the options \fBoptions\fP.
The program \fBprogname\fP must exist somewhere in the user's
path.
.PP
The state assignment program is given the current STG, and
returns a logic implementation.  After execution of the \fBstate_assign\fP
command, both the STG and the logic implementation are available
for optimization.
.PP
The state assignment program called must conform to the
specification (see doc/SPEC).
Currently, the programs that are compatible with this specification
and are shipped with SIS are nova and jedi.
To get help information for a specific program, use the -h option
(i.e. \fBstate_assign nova -h\fP would produce help information for
the nova state assignment program).
.PP
A one-hot encoding can be obtained by using \fBstate_assign progname -e h\fP.
Note that nova and jedi produce different results for one-hot encoding.
jedi produces typical one-hot codes (1000) while nova produces one-hot
codes with don't care conditions (1---).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
state_minimize progname options
.PP
Perform state minimization on the current STG.
The program used for state minimization is \fBprogname\fP
and it is given the options \fBoptions\fP.
The program \fBprogname\fP must exist somewhere in the user's
path.
.PP
The state minimization program is given the current STG, and
returns a new STG.  After execution of the \fBstate_minimize\fP
command, only the STG is available for optimization (any existing
logic implementation is removed, since there is no guarantee that
it implements the new STG).
.PP
The state minimization program called must conform to the
specification (see doc/SPEC).
Currently, the program that is compatible with this specification
and is shipped with \fBSIS\fR is \fBstamina\fR (from the University of Colorado,
Boulder, rho@boulder.colorado.edu).
To get help information for a specific program, use the \fB-h\fR option
(i.e. \fBstate_minimize stamina -h\fP would produce help information for
the \fBstamina\fR state minimization program).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
stg_cover
.PP
Check to see that the behavior of the STG covers
that of the logic implementation.
This operation is provided for the user to check that
two descriptions of the same machine are consistent.
Each edge in the STG is symbolically simulated in the
logic implementation to ensure that the logic implementation
behaves as specified by the STG.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
stg_extract [-a] [-e] [-c]
.PP
Takes the current network and extracts the state transition graph from it.  
.PP
If the \fB-a\fP option is not specified, the values on the latches are taken
to be the start state, and every state reachable from the
start state is explored.  This is the normal method of execution.
.PP
If the \fB-a\fP option is specified, the state transition graph is extracted
for all possible start states, provided the number of latches does not
exceed 16.  This limitation cannot be overridden (there are too many
states to store).
.PP
Extraction of the STG could take an enormous amount of time.
If there are more than 16 latches in the network, \fBstg_extract\fR won't
attempt to extract the STG.
This can be overridden with the \fB-e\fP option.
.PP
At the end of \fBstg_extract\fR, a check is done to ensure that
the behavior of the STG is consistent with that of the logic implementation.
This is done with symbolic simulation using BDDs, and could be expensive.
\fBstg_extract\fR will not do this check for networks with more than
16 latches or more than 500 transitions unless the \fB-c\fR option is given.
.PP
Note: a \fBsweep\fI is done on the network before the STG is extracted.
This removes latches that do not fanout, so the sweep makes the extraction
more efficient.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
stg_to_astg [-v debug_level] 
.PP
Transforms the current State Transition Graph (that must satisfy the
Single Cube Restriction, see \fBastg_stg_scr\fR) into a Signal Transition
Graph.
.PP
Can be used to transform a burst-mode
Flow Table specification (written in .kiss format
and read using \fBread_kiss\fR) of an asynchronous circuit into a Signal
Transition Graph for subsequent encoding and synthesis (see
\fBastg_state_min\fR, \fBastg_to_f\fR and \fBastg_syn\fR).
.PP
Burst mode means that the circuit specified by the Flow Table may change state
only after all signals in a specified set (a "burst") have changed value. Many
bursts can occur from a given state, but no burst can be a subset of another
burst from the same state (or else meta-stability can occur).
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
stg_to_network [-e option]
.PP
Takes the current state-encoded state transition graph and generates 
an optimized two-level logic network.  The initial mapping is optimized
using a two-level Boolean minimizer (i.e. \fBespresso\fR)
along with the invalid
state codes as don't cares.
\fB-e\fR allows the user to specify how
the two-level logic-encoded network should be processed using \fBespresso\fR.
The option can be
either 0, 1, or 2.
The \fB-e 0\fR option simply runs espresso and executes \fBread_pla\fR.
The \fB-e 1\fR option runs \fBespresso\fR, but does a
\fBread_pla -s\fR instead.
This reads in the PLA in single-level form (fully collapsed) rather than 
two-level form.
This often produces better results.
The \fB-e 2\fR option
runs \fBespresso -Dso\fR, which does a single-output minimization.
Again, \fBread_pla -s\fR is used.
This option also produces better results for some
cases, but typically takes more time.
The default is the \fB-e 1\fR option.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
sweep
.PP
Successively eliminate all the single-input nodes and constant nodes 
(0 or 1) from the current network.
.PP
NOTE: Successfully invoking a sweep command on a mapped network can
possibly "unmap" the network.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
tech_decomp [-a and-limit] [-o or-limit] 
.PP
Decompose all the nodes in the current network into AND gates
or OR gates or both depending on whether \fB-a\fR,
\fB-o\fR, or both flags are specified.
The fanins of AND gates
will be no more than \fBand-limit\fR and that of the OR gates
will be no more than \fBor-limit\fR.  \fBand-limit\fR and
\fBor-limit\fR, if specified, must be at least 2.
The default option is \fB-a 2\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
time
.PP
Prints the processor time used since the last time command, and the total
processor time used since \fBSIS\fR was started.  
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
timeout [-t n] [-k]
.PP
Sends an interrupt to the \fBSIS\fR process. With no argument, this
routine inactivates any previous calls. 
.PP
The \fB-t n\fP specifies the timeout limit, in seconds.
.PP
The \fB-k\fP option specifies that a kill signal is to be sent to
\fBSIS\fR rather than a interrupt signal.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
alias [name [string]]
.X1
unalias name ...
.PP
The \fBalias\fR command, if given no arguments, will print the
definition of all current aliases.
Given a single argument, it
will print the definition of that alias (if any).
Given two
arguments, the keyword \fBname\fP becomes an alias for
the command string \fBstring\fP, replacing any other alias with the
same name.
The \fBunalias\fR command removes the definition of an alias.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
undo
.PP
A simple 1-level undo is supported.
It reverts the network to its state
before the last command which changed the network.
Note that interrupting
a command (with ^C) which changes the network 
uses up the one level of undo.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
set [name] [value]
.X1
unset name ...
.PP
A variable environment is maintained by the command interpreter.
The \fBset\fR command sets a variable to a particular value, and the
\fBunset\fR command removes the definition of a variable.
If \fBset\fR is given no arguments, it prints the definition of all variables.
.PP
Different commands use environment information for different purposes.
The command interpreter makes use of the following:
.TP 8
.B autoexec
Defines a command string to be automatically executed after every command
processed by the command interpreter.
This is useful for things like timing
commands, or tracing the progress of optimization.
.TP 8
.B sisout
Standard output (normally stdout) can be re-directed to a file
by setting the variable sisout.
.TP 8
.B siserr
Standard error (normally stderr) can be re-directed to a file
by setting the variable siserr.
.TP 8
.B history
Each valid command entered at the prompt can be echoed to a file
by setting the variable history.
.TP 8
.B history_char
By default the character `%' is used to do the history substitution
inside sis. This can be changed by setting the variable \fBhistory_char\fR.
.TP 8
.B shell_char
By default the character `!' is used to do invoke shell commands from
inside sis.  This can be changed by setting the variable \fBshell_char\fR.
\fI In order to switch the interpretation of shell_char and history_char it is
neccessary to first set history_char and then the shell_char. Alternately,
you may escape the current history char by preceeding it with
a `\' while setting the shell_char. In addition none of them can be set 
to a `#' which is reserved for comments.\fR
.TP 8
.B filec
Setting this variable enables the user to use "file-completion" like in 
the C-shell. An ESC causes the current line to be extended to its unique 
completion. A CTRL-d generates a list of the possible extensions.
.TP 8
.B open_path
\fBopen_path\fR (in analogy to the shell-variable PATH) is a list of
colon-separated strings giving directories to be searched whenever
a file is opened for read.  Typically the current directory (.) is
first in this list.  The standard system 
library (typically $SIS/sis_lib) is always implicitly appended 
to the current path.
This provides a convenient short-hand
mechanism for reaching standard library files.
.TP 8
.B prompt
defines the prompt string. If the prompt string contains a `%'(or whatever
the history_char has been set to using the set command), the `%'
will be replaced whenever the prompt is printed by the current event number.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
usage
.PP
Prints a formatted dump of processor-specific usage statistics.
For Berkeley Unix, this includes all of the information in the
\fIgetrusage()\fR structure.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
verify [-m method] [-v] file1 [file2]
.PP
Verify the Boolean equivalence of two networks.  \fBfile1\fR
is compared with the current network when \fBfile2\fR is not
specified, otherwise, \fBfile1\fR is compared with \fBfile2\fR.
The input and output variables from two networks are associated
by their names.
.PP
The \fB-m\fR option specifies the verification method.
If \fBmethod\fR is \fIclp\fR (default), two networks are collapsed and
compared as PLA's.
If \fBmethod\fR is \fIbdd\fR, the BDD's are constructed for both networks and
compared.
.PP
The \fB-v\fR option engages the "verbose" mode of verify.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
verify_fsm [-o depth] [-v n] [-m method] filename.blif
.PP
Verify the equivalence of two synchronous networks.
The current network is compared with \fBfilename.blif\fR.
The input and output variables from the two networks are
associated by their names.
It is assumed that all the latches in both designs are clocked
by a single, global clock.
The verification is done by implicitly enumerating all the
states in the product machine, and checking that the outputs
are equivalent for all reachable state pairs starting
from the initial state of the product machine.
.PP
\fB-o depth\fR allows the specification of the depth of search for a good
variable ordering.
A larger value for depth will require more CPU time but determine
a better ordering.
The default value is 2.
.PP
\fB-v\fR allows specification of the verbosity level of the output.
.PP
The \fB-m\fR option specifies \fBmethod\fR for determining
the reachable states.
\fBconsistency\fR builds the entire transition relation
and uses it to determine the reached states.
\fBbull\fR does output cofactoring to find the reachable
states.
The \fBproduct\fR method is similar to the \fBconsistency\fR method but
input variables are smoothed as soon as possible as the characteristic
function is being built.
This makes the size of the resulting BDD representing the
characteristic function of the transition relation smaller.
The default method is \fBproduct\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
wd [-c] node1 node2
.PP
The \fBwd\fR command (which stands for "weak division") is very similiar
to resubstitution (\fBresub\fR command), except that instead of operating
on the entire network, \fBwd\fR simply re-expresses \fBnode1\fR
in terms of \fBnode2\fR.
.PP
The \fB-c\fR option allows re-substitution of the
complement of \fBnode2\fR.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_astg [-p] [<file-name>]
.PP
Write a text description of an ASTG to a file, or stdout if no filename
is given.
See read_astg for a description of the format.
.PP
The -p option forces implied places to be written explicitly in the
description.
Normally a place with exactly one fanin and one fanout transition
is suppressed by specifying the fanout transition
as adjacent to the fanin transition.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_bdnet [filename]
.PP
Write the current network to file \fBfilename\fP in the format
for a net-list defined by bdnet(1).
This is allowed only after the network has been mapped into a final
implementation technology.
.PP
The environment variable OCT-CELL-PATH defines where the cell library
is located.  If a cell does not have a leading '~' or '/' in its name,
then OCT-CELL-PATH is prepended to the filename.
.PP
The variable OCT-CELL-VIEW defines the viewname to be used if the cell
does not have a ':' in its name to separate the cell name from the view
name.
.PP
The variables OCT-TECHNOLOGY, OCT-VIEWTYPE, and OCT-EDITSTYLE define
the technology, view-type, and edit-style properties for the Oct cell.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_blif [-s] [-n] [filename]
.PP
Write the current network to file \fBfilename\fP in the Berkeley
Logic Interchange Format (\fIblif\fP).
.PP
The \fB-s\fP option uses the network short names rather than the
network long names for the \fIblif\fP file.
This can be used to encrypt the names of a net-list.
.PP
The \fB-n\fP option uses the net-list format of \fIblif\fP when
a node has a gate implementation in the library.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_eqn [-s] [filename]
.PP
The \fBwrite_eqn\fR command prints out the equations from the current
network according to format specifications laid out in the
documentation for \fBread_eqn\fR.
Both primary inputs and outputs are indicated.
.PP
The \fB-s\fR option uses the network short names rather than the
network long names for the output.
.PP
If \fBfilename\fR is not specified the equations will be written to
standard out, otherwise they will be written into the given file and
may be read by \fBread_blif\fR at a later time.
.PP
Note that since the eqn format uses the '(' and ')' characters
for grouping, they cannot appear in any of the signal names.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_kiss [filename]
.PP
The current state transition graph is saved in \fIkiss2\fP format to the
file \fBfilename\fP or printed to the screen if no filename is given.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_oct [-m] cell[:view]
.PP
Write the current network to the Oct facet \fBcell:view:contents\fR.
If \fBview\fR is not specified, it will default to `logic'.
.PP
If the \fB-m\fR flag is specified, the network is merged into an existing
network.
All of the logic elements and internal nets are ripped up and replaced
with the new network.
Oct net names are used to determine how to merge in the network, so
if the net names at the interface of the logic are not defined the
merge will fail.
.PP
The environment variable OCT-CELL-PATH defines where the cell library
is located.  If a cell does not have a leading '~' or '/' in its name,
then OCT-CELL-PATH is prepended to the filename.
.PP
The variable OCT-CELL-VIEW defines the viewname to be used if the cell
does not have a ':' in its name to separate the cell name from the view
name.
.PP
The variables OCT-TECHNOLOGY, OCT-VIEWTYPE, and OCT-EDITSTYLE define
the technology, view-type, and edit-style properties for the Oct facet.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_pds [-c] [-d] [-s] [filename]
.PP
Write the current network to file \fBfilename\fP in the \fIpds\fP
format suitable for Xilinx.  
The \fIpds\fP descriptions are generated for single output CLBs
(LUTs) only.
.PP
The \fB-c\fP option indicates that only the combinational portion
of the network should be written out.
.PP
The \fB-d\fP option will cause debugging information to be printed.
.PP
The \fB-s\fP option uses the network short names rather than the
network long names for the \fIpds\fP file.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_pla [filename]
.PP
Write the current network to file \fBfilename\fP in the Berkeley
PLA Format.  No optimization is done on the PLA.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
write_slif [-s] [-n] [-d] [filename]
.PP
Write the current network to the file \fBfilename\fP in the Stanford Logic
Interchange Format (\fISLIF\fP).
.PP
The \fB-s\fP option uses the network short names rather than the network
long names for the \fISLIF\fP file.  This can be used to encrypt the names of a
net-list.
.PP
The \fB-n\fP option uses the net-list format of \fISLIF\fP when a node has a
gate implementation in the library.
.PP
The \fB-d\fP option makes the \fISLIF\fR writer print out any delay information
known about the current network.  This is not the default because a standard
for printing delay information has not been established for the
\fISLIF\fP format.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
XILINX
.br
Description
.br
.PP
This is a package to optimize the Boolean network and map it onto
the Xilinx Programmable Gate Array architecture
(reference: Xilinx, the Programmable Gate Array Data Book,
Xilinx Corporation).
All the routines except \fBxl_merge\fR can be used to map the design
onto an architecture with a CLB (Configurable Logic Block) realizing an
arbitrary function of up to n inputs,  where n >= 2.
The package contains the following commands available to the user 
for experimentation.
.br
.PP
Suggested script
.br
.PP
time
.br
.PP
sweep
.br
.PP
simplify
.br
.PP
sweep
.br
.PP
simplify
.br
.PP
xl_split -n  5
.br
.PP
sweep
.br
.PP
simplify
.br
.PP
xl_split -n 5
.br
.PP
sweep
.br
.PP
xl_partition -n 5
.br
.PP
sweep
.br
.PP
simplify
.br
.PP
xl_partition -n 5
.br
.PP
sweep
.br
.PP
xl_k_decomp -n 5
.br
.PP
sweep
.br
.PP
xl_cover -n 5 -h 3
.br
.PP
xl_merge
.br
.PP
time
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_absorb [-n support] [-f MAX_FANINS] [-v]
.PP
Given a possibly infeasible network, moves fanins of the nodes so as
to decrease their number of fanins. Some infeasible
nodes may become feasible and decomposition may not be applied on
them. 
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.br
.PP
\fB-f\fP: Does not move fanins of a node if it has more than MAX_FANINS
(default 15). 
.br
.PP
\fB-v\fP: turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_ao [-n support] 
.PP
Uses a cube-packing heuristic to do an AND-OR decomposition of an infeasible network.
This is fast and the result is a feasible network.
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_coll_ck [-n support] [-c collapse_input_limit] [-kv]
.PP
Assumes a feasible network.
If the number of inputs to the network is at most
\fBcollapse_input_limit\fP (default 9), collapse the network,
apply Roth-Karp decomposition and cofactoring schemes.
Pick the best result and compare with the original network
(before collapsing). If the number of nodes is smaller, accept the 
better decomposition. Does nothing if n = 2.
.PP
\fB-k\fP: does not apply Roth-Karp decomposition, just use cofactoring.
.br
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.br
.PP
\fB-v\fP: turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_cover [-n number] [-h heuristic number]
.br
.PP
For mapping onto Xilinx architecture.
The initial network
should have all intermediate nodes with fanin less than
or equal to \fBnumber\fP (default is 5).
Mathony's binate covering algorithm is used to
minimize the number of nodes in the network.
Different heuristics are used to solve the covering
problem. The heuristic number can be specified
by \fB-h\fP option. Heuristic number can be 0, 1, 2 or 3:
.br
.PP
-  0 (exact),
.PP
-  1 (Mathony's method - stop when first leaf is reached),
.PP
-  2 (For large examples),
.PP
-  3 (default:  automatically decides between 0 and 2)
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_decomp_two [-n support] [-l lower_common_bound]
            [-L cube_support_lower_bound] [-f MAX_FANIN]
            [-c MAX_COMMON_FANIN] [-u MAX_UNION_FANIN] [-v]
.PP
Given an infeasible network, does decomposition
knowing that each Xilinx3090 CLB can have two functions if they have
no more than MAX_FANIN (default = 4) fanins each, their union has at
most MAX_UNION_FANINS (default = 5) fanins and they have at most
MAX_COMMON_FANINS (default = 4) common fanins. It does so by
considering certain cubes of all the infeasible nodes of the network, and
associating an affinity value with each cube-pair. Extracts
cube-pairs with high affinity. Need to do a decomposition later to
make the network feasible.
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.br
.PP
\fB-l\fP: do not consider a cube-pair for extraction if their number of
common inputs is less than lower_common_bound (default = 2).
.br
.PP
\fB-L\fP: do not consider a cube if it has less than
cube_support_lower_bound inputs.
.br
.PP
\fB-v\fP: turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_imp [-n support] [-c cover_node_limit] [-l lit_bound] [-Aabm]
     [-g good_decomp] [-M MAX_FANINS]
     [-v verbosity level] 
.PP
Given an infeasible network, replaces each internal infeasible node
by a set of feasible nodes. These nodes are derived by trying
different decomposition strategies (like xl_ao, xl_split,
cofactoring, decomp -d and tech_decomp -a 2 -o 2), each followed
by a partition/cover phase. In the end, picks the best result (the
one with minimum number of feasible nodes). The result is a feasible network. 
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.br
.PP
\fB-A\fP  do not move fanins around after decomp -g.
.br
.PP
\fB-a\fP:  do not apply all decomposition methods. Only cube-packing on
sum-of-product (SOP), cube-packing on factored-form (if g flag
!= 0) and cofactoring. If this option is not specified, also apply
Roth-Karp, tech_decomp, decomp -d, and xl_split.
.br
.PP
\fB-b\fP:  for best results, use this option.
Effective on a node only if its number of
literals is greater than lit_bound. In that case, after the good decomposition,
recursively call the command for each of the nodes in 
decomposition. Time consuming.
.br
.PP
\fB-c\fP:  sets the limit for the cover algorithm used after each
decomposition. If the number of feasible nodes for an infeasible node
is no more than cover_node_limit, then exact cover is used, else
heuristic (-h 3) option is used. (default = 25).
.br
.PP
\fB-g\fP:  if 0 (default), do not use decomp -g for cube-packing, just
SOP. If 1, use only decomp -g, not SOP. If 2, use both decomp -g and SOP for
cube-packing, and pick the best result.
.br
.PP
\fB-l\fP:  if the infeasible node has greater than lit_bound literals,
does a good decomposition of the node (i.e. decomp -g) (default: 50)
.br
.PP
\fB-m\fP:  While doing partition, move fanins around for a node with at
most MAX_FANINS (default 15).  
.br
.PP
\fB-v\fP: this sets the verbosity level (amount of information printed
as the algorithm proceeds) to \fBverbosity_level\fP.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_k_decomp [-n support] [-p node_name] [-v verbosity_level] [-f MAX_FANINS_K_DECOMP] [-de]
.PP
Uses Karp_Roth disjoint decomposition to recursively decompose
nodes of the network having fanin greater than 
\fBsupport\fP to obtain nodes each having 
fanin of at most \fBsupport\fP.
If \fB-p node_name\fP is specified, only the node with the name
\fBnode_name\fP is decomposed.
Otherwise, all the nodes 
that have fanin greater than \fBsupport\fP are
decomposed.
If \fB-d\fP option is specified, then if k_decomp fails to find a disjoint decomposition on a node,
the node is not decomposd by cube-packing. Option \fB-e\fP allows an exhaustive search over all 
possible partitions to pick the best decomposition of a node. Then the option \fB-f MAX_FANINS_K_DECOMP\fP
sets the limit on maximum number of fanins of a node for exhaustive decomposition. If the number of fanins
is higher, only the first input partition is considered. 

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_merge [-f MAX_FANIN] [-c MAX_COMMON_FANIN] [-u MAX_UNION_FANIN] 
         [-n support] [-o filename] [-vlF]
.PP
Used for mapping onto Xilinx architecture.
It selects pairs of nodes of the network that can be merged
so as to minimize the number of nodes.
and solves an integer program using the package Lindo.
In the end it lists the pairs of nodes that were merged.
The command does not change the network.
.PP
\fB-f\fP: MAX_FANIN is the limit on the fanin of a mergeable node (default = 4).
.br
.PP
\fB-c\fP: MAX_COMMON_FANIN is the limit on the common fanins of two
mergeable nodes (default = 4).
.br
.PP
\fB-u\fP: MAX_UNION_FANIN is the limit on the union of the fanins of two
mergeable nodes (default = 5).
.br
.PP
\fB-n\fP: support is the limit on the number of fanins of a single function that 
can be put on a CLB (default = 5).
.br
.PP
\fB-o\fP: filename is the file in which information about the nodes merged is 
printed. Must specify.
.br
.PP
\fB-l\fP: Do not use lindo, an integer-linear programming package used to solve 
the matching problem. Instead use a heuristic. If not specified, the program first 
searches for lindo in the path. If found, lindo is invoked, else the program 
automatically calls the heuristic.
.br
.PP
\fB-F\fP: If the input network is say a 4-feasible network and the support = 5, it 
may be possible to reduce the number of nodes after matching. If this option is not 
used,\fBxl_partition\fP is called after matching step on the subnetwork composed of 
unmatched nodes. Otherwise, only matching is done and the network remains unchanged.
.br
.PP
\fB-v\fP:  turns on the verbosity flag.  When used, information about the
   algorithm is printed as it executes.

.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_part_coll [-n support] [-C cost_limit] [-c cover_node_limit] 
           [-l lit_bound] [-Aabm] [-g decomp_good]
           [-M MAX_FANINS] [-v verbosity_level]
.PP
This is a partial collapse routine.  On an infeasible network,
first runs trivial partition routine. Then for each node,
finds the cost of the node using a routine similar to \fBxl_imp\fP.
Collapses each node into fanouts and computes the cost of the
fanouts likewise. If the new cost of the fanouts is less, accepts
the collapse. Deletes the collapsed node from the network. 
It does this until no more collapses can be beneficially carried out.
The nodes are visited topologically. 
The result is a feasible network.
.PP        
\fB-C\fP: tries only those nodes for collapsing whose cost is less
than or equal to cost_limit.
Our experience has been that it is beneficial to collapse
only feasible nodes. So the default is 1.
.br
.PP
Other options are the same as in \fBxl_imp\fP except -c has default of
10 and -A means move fanins around.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_partition [-n support] [-M MAX_FANINS] [-v verbosity_level] [-tm]
.PP
Tries to reduce the number of nodes by collapsing nodes into their
fanouts. Also takes into account extra nets created. Collapses a
node into its fanout only if the resulting fanout is feasible.
Associates a cost with each (node, fanout) pair which reflects the
extra nets created if node is collapsed into the fanout. It then selects
pairs with lowest costs and collapses them.
The starting network need not be feasible, in which case
the resulting network also may not be. But if the starting network is,
so is the resulting network.
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.br
.PP
\fB-t\fP: Our experience was that if one is just interested in
minimization of number of nodes, then those nodes which can
be collapsed into all their fanouts are the main reduction-contributors.
This option removes a node from the network if it
can be collapsed into all its fanouts. Very fast.
.br
.PP
\fB-m\fP: move fanins around to increase collapsing possibilities. Do so for a node 
only if after collapsing, it has at most MAX_FANINS (default = 15)(as specified by \fB-M\fP option).
.br
.PP
\fB-v\fP: this sets the verbosity level (amount of information printed
as the algorithm proceeds) to \fBverbosity_level\fP.
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_rl [-n support] [-m] [-M MAX_FANINS] 
    [-t (trav_method-levels)] [-c collapse_input_limit]
    [-v verbosity_level]
.PP
Used for timing optimization for table look up architectures (phase 1).
Given a feasible network (obtained say by using speed_up), reduces number of
levels for table look up with "support" inputs.  If \fB-m\fP is not given,
it tries to move fanins for each node also, provided the number of
fanins of the node does not exceed MAX_FANINS (default 15). As a
final step, tries collapsing the network if number of inputs to the
network is at most collapse_input_limit (default = 10). Then applies
Roth-Karp decomposition and cofactoring (support > 2). If number of 
levels decreases, accepts the better decomposition. 
.PP
\fB-n\fP: support is the size of the TLU block (default = 5)
.\" /*
.\"  * Revision Control Information
.\"  *
.\"  * $Source: /users/pchong/CVS/sis/sis/sis_lib/help/sis.1,v $
.\"  * $Author: pchong $
.\"  * $Revision: 1.1.1.1 $
.\"  * $Date: 2004/02/07 10:14:34 $
.\"  *
.\"
.XX
xl_split [-n value] [-d]
.PP
Ensures that every node in the network has number of fanins less than or
equal to \fBvalue\fP.
This is accomplished by using kernel extraction and AND-OR decomposition.
\fB-d\fP turns on debugging facilities.
.SH FILES
$SIS/ex
.br
$SIS/sis_lib/.misrc
.br
$SIS/sis_lib/.sisrc
.br
$SIS/sis_lib/script
.br
$SIS/sis_lib/*
.SH "SEE ALSO"
espresso(1CAD), espresso(5CAD), eqntott(1CAD), nova(1CAD),
stamina(UC Boulder), jedi(1CAD), doc/blif.tex, doc/SPEC.
.SH AUTHORS
Ellen Sentovich
.br
Kanwar Jit Singh
.SH OTHER CONTRIBUTORS
Bill Lin, Luciano Lavagno, Sharad Malik, Cho Moon, Rajeev Murgai,
Alex Saldanha, Hamid Savoj, Narendra Shenoy, Tom Shiple, Paul Stephan,
Colin Stevens, Herve Touati, Tiziano Villa, and Carol Wawrukiewicz.
Jose Monteiro (MIT) contributed the power estimation package.
David Long (AT&T Bell Laboratories) contribued the BDD package.
June Rho (CU Boulder) contributed the stamina program.
Roberto Rambaldi (D.E.I.S. Universita' di Bologna) contributed
the vst2blif program.
Richard Rudell and Albert Wang wrote the program MISII, upon which
SIS is built.
.SH BUGS
If a state machine has only one state, calling state assignment using
nova causes a fatal error.  This is due to the fact that if a PLA has
outputs that are all 0, espresso returns no PLA (when the type requested
is the ON-set).  nova tries to read the pla using SIS and fails.

The simulate command does not work as it should for sequential circuits.
Gated clocks are not simulated correctly, and incorrect results are obtained
when the network has a clock and the STG does not.

.SH COMMENTS
Mapping information is lost during factoring.  Once a circuit is mapped,
it is not expected that any further operations on the logic will
be performed, hence, if they are, the mapping is lost.

Many of the new routines (e.g. extract_seq_dc, full_simplify, verify_fsm)
use BDDs and can be very time- and memory-consuming.
Work is underway on this problem.
