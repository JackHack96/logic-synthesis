<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Univr Logic Sythesis Software</title>

    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="css/simple-sidebar.css" rel="stylesheet">

    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="js/navbar-tutorials.js"></script>

</head>

<body>
    <div id="sidenav"></div>

    <div class="main">
        <p id="tutorials">
            <p id="4-bit-adder">
                <h2>A 4-bit full adder</h2>
                <p>
                    In this tutorial, you'll see how to create a small 4-bit full adder, starting from scratch.
                    The full adder is a logical circuit with 3 inputs and 2 outputs. It's built by combining two
                    half-adders
                    with a logical OR port, so we must first create our half adder.
                    An half adder sums two bits, A and B, and gives two outputs, S and C. S is the sum and C is the
                    carry.
                    The half adder differs from the full adder because it doesn't care about the previous carry.
                </p>
                Here is the truth table of a half adder:
                <table class="table" style="text-align:center">
                    <thead>
                        <tr>
                            <th colspan="2" style="text-align:center">Inputs</td>
                            <th colspan="2" style="text-align:center">Outputs</td>
                        </tr>
                        <tr>
                            <th scope="col" style="text-align:center">A</th>
                            <th scope="col" style="text-align:center">B</th>
                            <th scope="col" style="text-align:center">S</th>
                            <th scope="col" style="text-align:center">C</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    The diagram is realized by using an AND gate combined with a XOR gate
                    <p style="text-align: center">
                        <img src="img/half_adder.png" class="img-thumbnail" style="max-width:30%; height: auto;">
                    </p>
                    We could represent the circuit using a BLIF file, but it's not necessary since we can code directly
                    the
                    full adder.
                </p>
                <p>
                    Now that we have our half adder, we can build the full version, which actually
                    accounts for values carried in besides out.
                    The logic diagram of a full adder should look like this:
                    <p style="text-align:center">
                        <img src="img/full_adder.png" class="img-thumbnail" style="max-width: 100%; height: auto">
                    </p>
                </p>
                But we are more interested in the truth table, which is:
                <table class="table" style="text-align:center">
                    <thead>
                        <tr>
                            <th colspan="3" style="text-align:center">Inputs</td>
                            <th colspan="2" style="text-align:center">Outputs</td>
                        </tr>
                        <tr>
                            <th scope="col" style="text-align:center">A</th>
                            <th scope="col" style="text-align:center">B</th>
                            <th scope="col" style="text-align:center">C_IN</th>
                            <th scope="col" style="text-align:center">S</th>
                            <th scope="col" style="text-align:center">C_OUT</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td>0</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                        </tr>
                    </tbody>
                </table>
                <b>We can proceed to write a BLIF for representing the 1-bit full adder!</b>
                The code should look something like this:
                <pre>
                    <code>
    #1-bit adder
    #Data bits: 1
    
    .model ADDER
    .inputs a b cin
    .outputs o cout
    
    .names a b k
    10 1
    01 1
    
    .names k cin o
    10 1
    01 1
    
    .names a b cin cout
    11- 1
    1-1 1
    -11 1
    
    .end
                    </code>
                </pre>
                Ok, but what about the 4 bit adder? Do I have to make such a big BLIF file with loads of truth tables?
                No! We simply reuse the 1-bit adder 4 times! The magic happens by using the <code>.subckt</code>
                keyword, which allows
                you to use a preloaded model you load with the <code>.search</code> keyword. Be aware that the model
                must be in the
                same directory. So the 4-bit adder would look like this:
                <pre>
                    <code>
    #4-bit adder
    #Data bits: 4
    
    .model ADDER4
    .inputs a3 a2 a1 a0 b3 b2 b1 b0 cin
    .outputs o3 o2 o1 o0 cout
    
    #C[x] is a temporary variable, used for the carry-out of the addition
    .subckt ADDER a=a0 b=b0 cin=cin o=o0 cout=C0
    .subckt ADDER a=a1 b=b1 cin=C0 o=o1 cout=C1
    .subckt ADDER a=a2 b=b2 cin=C1 o=o2 cout=C2
    .subckt ADDER a=a3 b=b3 cin=C2 o=o3 cout=cout
    .search ADDER.blif
    
    .end
                    </code>
                </pre>
                Now we can simulate it to see if it's correct.
                <pre>
                    <code>
    UC Berkeley, SIS 1.3.6 (compiled 2017-10-27 16:08:57)
    sis> read_blif ADDER4.blif
    sis> sim 0 0 0 1 0 0 0 1 0
    
    Network simulation:
    Outputs: 0 0 1 0 0
    Next state: 
    sis> sim 0 0 1 0 0 0 1 0 0
    
    Network simulation:
    Outputs: 0 1 0 0 0
    Next state: 
    sis> 
                    </code>
                </pre>
                Ok! It works!
            </p>
    </div>
</body>

</html>